{
  "groups": [
    {
      "group_id": 1,
       "duplicates": [
        {
          "start_index": 0,
           "end_index": 5374,
           "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <plainxml>The 802.11 subsystems &amp;ndash; for kernel developers Explaining wireless 802.11 networking in the Linux kernel 2007-2009Johannes BergJohannesBergjohannes@sipsolutions.net This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This documentation is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this documentation; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. These books attempt to give a description of the various subsystems that play a role in 802.11 wireless networking in Linux. Since these books are for kernel developers they attempts to document the structures and functions used in the kernel as well as giving a higher-level overview. The reader is expected to be familiar with the 802.11 standard as published by the IEEE in 802.11-2007 (or possibly later versions). References to this standard will be given as &quot;802.11-2007 8.1.5&quot;. The cfg80211 subsystem Device registration Actions and configuration Scanning and BSS list handling Utility functions Data path helpers Regulatory enforcement infrastructure RFkill integration Test mode The mac80211 subsystem &lt;!-- Generally, this document shall be ordered by increasing complexity. It is important to note that readers should be able to read only the first few sections to get a working driver and only advanced usage should require reading the full document. --&gt;The basic mac80211 driver interface You should read and understand the information contained within this part of the book while implementing a driver. In some chapters, advanced usage is noted, that may be skipped at first. This part of the book only covers station and monitor mode functionality, additional information required to implement the other modes is covered in the second part of the book. Basic hardware handlingTBD This chapter shall contain information on getting a hw struct allocated and registered with mac80211. Since it is required to allocate rates/modes before registering a hw struct, this chapter shall also contain information on setting up the rate/mode structs. Additionally, some discussion about the callbacks and the general programming model should be in here, including the definition of ieee80211_ops which will be referred to a lot. Finally, a discussion of hardware capabilities should be done with references to other parts of the book. &lt;!-- intentionally multiple !F lines to get proper order --&gt; PHY configurationTBD This chapter should describe PHY handling including start/stop callbacks and the various structures used. Virtual interfacesTBD This chapter should describe virtual interface basics that are relevant to the driver (VLANs, MGMT etc are not.) It should explain the use of the add_iface/remove_iface callbacks as well as the interface configuration callbacks. Things related to AP mode should be discussed there. Things related to supporting multiple interfaces should be in the appropriate chapter, a BIG FAT note should be here about this though and the recommendation to allow only a single interface in STA mode at first! Receive and transmit processingwhat should be hereTBD This should describe the receive and transmit paths in mac80211/the drivers as well as transmit status handling. Frame format Packet alignment Calling into mac80211 from interrupts functions/definitions Frame filtering The mac80211 workqueue Advanced driver interface Information contained within this part of the book is of interest only for advanced interaction of mac80211 with drivers to exploit more hardware capabilities and improve performance. LED support Mac80211 supports various ways of blinking LEDs. Wherever possible, device LEDs should be exposed as LED class devices and hooked up to the appropriate trigger, which will then be triggered appropriately by mac80211. Hardware crypto acceleration &lt;!-- intentionally multiple !F lines to get proper order --&gt; Powersave support Beacon filter support Multiple queues and QoS supportTBD Access point mode supportTBDSome parts of the if_conf should be discussed here instead Insert notes about VLAN interfaces with hw crypto here or in the hw crypto chapter. support for powersaving clients Supporting multiple virtual interfacesTBD Note: WDS with identical MAC address should almost always be OK Insert notes about having multiple virtual interfaces with different MAC addresses here, note which configurations are supported by mac80211, add notes about supporting hw crypto with it. Station handlingTODO Hardware scan offloadTBD AggregationTX A-MPDU aggregation RX A-MPDU aggregation Spatial Multiplexing Powersave (SMPS) Rate control interfaceTBD This part of the book describes the rate control algorithm interface and how it relates to mac80211 and drivers. Rate Control APITBD InternalsTBD This part of the book describes mac80211 internals."
        },
         {
          "start_index": 5375,
           "end_index": 10917,
           "text": "Key handlingKey handling basics MORE TBDTBDReceive processingTBDTransmit processingTBDStation info handlingProgramming information STA information lifetime rules Aggregation STA SynchronisationTBDLocking, lots of RCUThe 802.11 subsystems &amp;ndash; for kernel developers Explaining wireless 802.11 networking in the Linux kernel 2007-2009Johannes BergJohannesBergjohannes@sipsolutions.net This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This documentation is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this documentation; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. These books attempt to give a description of the various subsystems that play a role in 802.11 wireless networking in Linux. Since these books are for kernel developers they attempts to document the structures and functions used in the kernel as well as giving a higher-level overview. The reader is expected to be familiar with the 802.11 standard as published by the IEEE in 802.11-2007 (or possibly later versions). References to this standard will be given as &quot;802.11-2007 8.1.5&quot;. The cfg80211 subsystem Device registration Actions and configuration Scanning and BSS list handling Utility functions Data path helpers Regulatory enforcement infrastructure RFkill integration Test mode The mac80211 subsystem &lt;!-- Generally, this document shall be ordered by increasing complexity. It is important to note that readers should be able to read only the first few sections to get a working driver and only advanced usage should require reading the full document. --&gt;The basic mac80211 driver interface You should read and understand the information contained within this part of the book while implementing a driver. In some chapters, advanced usage is noted, that may be skipped at first. This part of the book only covers station and monitor mode functionality, additional information required to implement the other modes is covered in the second part of the book. Basic hardware handlingTBD This chapter shall contain information on getting a hw struct allocated and registered with mac80211. Since it is required to allocate rates/modes before registering a hw struct, this chapter shall also contain information on setting up the rate/mode structs. Additionally, some discussion about the callbacks and the general programming model should be in here, including the definition of ieee80211_ops which will be referred to a lot. Finally, a discussion of hardware capabilities should be done with references to other parts of the book. &lt;!-- intentionally multiple !F lines to get proper order --&gt; PHY configurationTBD This chapter should describe PHY handling including start/stop callbacks and the various structures used. Virtual interfacesTBD This chapter should describe virtual interface basics that are relevant to the driver (VLANs, MGMT etc are not.) It should explain the use of the add_iface/remove_iface callbacks as well as the interface configuration callbacks. Things related to AP mode should be discussed there. Things related to supporting multiple interfaces should be in the appropriate chapter, a BIG FAT note should be here about this though and the recommendation to allow only a single interface in STA mode at first! Receive and transmit processingwhat should be hereTBD This should describe the receive and transmit paths in mac80211/the drivers as well as transmit status handling. Frame format Packet alignment Calling into mac80211 from interrupts functions/definitions Frame filtering The mac80211 workqueue Advanced driver interface Information contained within this part of the book is of interest only for advanced interaction of mac80211 with drivers to exploit more hardware capabilities and improve performance. LED support Mac80211 supports various ways of blinking LEDs. Wherever possible, device LEDs should be exposed as LED class devices and hooked up to the appropriate trigger, which will then be triggered appropriately by mac80211. Hardware crypto acceleration &lt;!-- intentionally multiple !F lines to get proper order --&gt; Powersave support Beacon filter support Multiple queues and QoS supportTBD Access point mode supportTBDSome parts of the if_conf should be discussed here instead Insert notes about VLAN interfaces with hw crypto here or in the hw crypto chapter. support for powersaving clients Supporting multiple virtual interfacesTBD Note: WDS with identical MAC address should almost always be OK Insert notes about having multiple virtual interfaces with different MAC addresses here, note which configurations are supported by mac80211, add notes about supporting hw crypto with it. Station handlingTODO Hardware scan offloadTBD AggregationTX A-MPDU aggregation RX A-MPDU aggregation Spatial Multiplexing Powersave (SMPS) Rate control interfaceTBD This part of the book describes the rate control algorithm interface and how it relates to mac80211 and drivers. Rate Control APITBD InternalsTBD This part of the book describes mac80211 internals."
        }
      ]
    },
     {
      "group_id": 2,
       "duplicates": [
        {
          "start_index": 10918,
           "end_index": 13942,
           "text": "Key handlingKey handling basics MORE TBDTBDReceive processingTBDTransmit processingTBDStation info handlingProgramming information STA information lifetime rules Aggregation SynchronisationTBDLocking, lots of RCU&lt;!-- ****************************************************** --&gt;&lt;!-- Header --&gt;&lt;!-- ****************************************************** --&gt;The ALSA Driver API This document is free; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This document is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA Management of Cards and DevicesCard Management Device Components Module requests and Device File Entries Memory Management Helpers PCM APIPCM Core PCM Format Helpers PCM Memory Management Control/Mixer APIGeneral Control Interface AC97 Codec API Virtual Master Control API MIDI APIRaw MIDI API MPU401-UART API Proc Info APIProc Info Interface Miscellaneous FunctionsHardware-Dependent Devices API Jack Abstraction Layer API ISA DMA Helpers Other Helper Macros Debug objects life timeThomasGleixnertglx@linutronix.de2008Thomas Gleixner This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction debugobjects is a generic infrastructure to track the life time of kernel objects and validate the operations on those. debugobjects is useful to check for the following error patterns: Activation of uninitialized objectsInitialization of active objectsUsage of freed/destroyed objects debugobjects is not changing the data structure of the real object so it can be compiled in with a minimal runtime impact and enabled on demand with a kernel command line option. Howto use debugobjects A kernel subsystem needs to provide a data structure which describes the object type and add calls into the debug code at appropriate places. The data structure to describe the object type needs at minimum the name of the object type."
        },
         {
          "start_index": 33061,
           "end_index": 34606,
           "text": "Bus-Independent Device AccessesMatthewWilcoxmatthew@wil.cxAlanCoxalan@lxorguk.ukuu.org.uk2001Matthew Wilcox This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction Linux provides an API which abstracts performing IO across all busses and devices, allowing device drivers to be written independently of bus type. Known Bugs And Assumptions None. Memory Mapped IOGetting Access to the Device The most widely supported form of IO is memory mapped IO. That is, a part of the CPU&#39;s address space is interpreted not as accesses to memory, but as accesses to a device. Some architectures define devices to be at a fixed address, but most have some method of discovering devices. The PCI bus walk is a good example of such a scheme. This document does not cover how to receive such an address, but assumes you are starting with one."
        },
         {
          "start_index": 315171,
           "end_index": 316623,
           "text": "Reed-Solomon Library Programming InterfaceThomasGleixnertglx@linutronix.de2004Thomas Gleixner This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction The generic Reed-Solomon Library provides encoding, decoding and error correction functions. Reed-Solomon codes are used in communication and storage applications to ensure data integrity. This documentation is provided for developers who want to utilize the functions provided by the library. Known Bugs And Assumptions None. Usage This chapter provides examples of how to use the library. Initializing The init function init_rs returns a pointer to an rs decoder structure, which holds the necessary information for encoding, decoding and error correction with the given polynomial. It either uses an existing matching decoder or creates a new one."
        },
         {
          "start_index": 374186,
           "end_index": 375678,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction This document describes the interfaces available for device drivers that drive s390 based channel attached I/O devices. This includes interfaces for interaction with the hardware and interfaces for interacting with the common driver core. Those interfaces are provided by the s390 common I/O layer. The document assumes a familarity with the technical terms associated with the s390 channel I/O architecture. For a description of this architecture, please refer to the &quot;z/Architecture: Principles of Operation&quot;, IBM publication no. SA22-7832. While most I/O devices on a s390 system are typically driven through the channel I/O mechanism described here, there are various other methods (like the diag interface)."
        },
         {
          "start_index": 386707,
           "end_index": 388315,
           "text": "Memory ManagementSH-4Store Queue API SH-5TLB Interfaces Machine Specific Interfacesmach-dreamcast mach-x3proto BussesSuperHyway Maple The Linux Kernel Tracepoint APIJasonBaronjbaron@redhat.comWilliamCohenwcohen@redhat.com This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction Tracepoints are static probe points that are located in strategic points throughout the kernel. &#39;Probes&#39; register/unregister with tracepoints via a callback mechanism. The &#39;probes&#39; are strictly typed functions that are passed a unique set of parameters defined by each tracepoint. From this simple callback mechanism, &#39;probes&#39; can be used to profile, debug, and understand kernel behavior. There are a number of tools that provide a framework for using &#39;probes&#39;. These tools include Systemtap, ftrace, and LTTng. Tracepoints are defined in a number of header files via various macros."
        }
      ]
    },
     {
      "group_id": 3,
       "duplicates": [
        {
          "start_index": 14957,
           "end_index": 16093,
           "text": "Debug functionsDebug object function reference debug_object_init This function is called whenever the initialization function of a real object is called. When the real object is already tracked by debugobjects it is checked, whether the object can be initialized. Initializing is not allowed for active and destroyed objects. When debugobjects detects an error, then it calls the fixup_init function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real initialization of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem. When the real object is not yet tracked by debugobjects, debugobjects allocates a tracker object for the real object and sets the tracker object state to ODEBUG_STATE_INIT. It verifies that the object is not on the callers stack. If it is on the callers stack then a limited number of warnings including a full stack trace is printk&#39;ed. The calling code must use debug_object_init_on_stack() and remove the object before leaving the function which allocated it. See next section."
        },
         {
          "start_index": 16094,
           "end_index": 17261,
           "text": "debug_object_init_on_stack This function is called whenever the initialization function of a real object which resides on the stack is called. When the real object is already tracked by debugobjects it is checked, whether the object can be initialized. Initializing is not allowed for active and destroyed objects. When debugobjects detects an error, then it calls the fixup_init function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real initialization of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem. When the real object is not yet tracked by debugobjects debugobjects allocates a tracker object for the real object and sets the tracker object state to ODEBUG_STATE_INIT. It verifies that the object is on the callers stack. An object which is on the stack must be removed from the tracker by calling debug_object_free() before the function which allocates the object returns. Otherwise we keep track of stale objects. debug_object_activate This function is called whenever the activation function of a real object is called."
        }
      ]
    },
     {
      "group_id": 4,
       "duplicates": [
        {
          "start_index": 17263,
           "end_index": 17370,
           "text": "When the real object is already tracked by debugobjects it is checked, whether the object can be activated."
        },
         {
          "start_index": 18340,
           "end_index": 18441,
           "text": "When the real object is tracked by debugobjects it is checked, whether the object can be deactivated."
        },
         {
          "start_index": 18863,
           "end_index": 18962,
           "text": "When the real object is tracked by debugobjects it is checked, whether the object can be destroyed."
        },
         {
          "start_index": 19537,
           "end_index": 19632,
           "text": "When the real object is tracked by debugobjects it is checked, whether the object can be freed."
        },
         {
          "start_index": 20530,
           "end_index": 20600,
           "text": "When the real object is already tracked by debugobjects it is ignored."
        }
      ]
    },
     {
      "group_id": 5,
       "duplicates": [
        {
          "start_index": 17372,
           "end_index": 17971,
           "text": "Activating is not allowed for active and destroyed objects. When debugobjects detects an error, then it calls the fixup_activate function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real activation of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem. When the real object is not yet tracked by debugobjects then the fixup_activate function is called if available. This is necessary to allow the legitimate activation of statically allocated and initialized objects."
        },
         {
          "start_index": 18963,
           "end_index": 19535,
           "text": "Destruction is not allowed for active and destroyed objects. When debugobjects detects an error, then it calls the fixup_destroy function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real destruction of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem. When the destruction is legitimate, then the state of the associated tracker object is set to ODEBUG_STATE_DESTROYED. debug_object_free This function is called before an object is freed."
        }
      ]
    },
     {
      "group_id": 6,
       "duplicates": [
        {
          "start_index": 18114,
           "end_index": 18227,
           "text": "When the activation is legitimate, then the state of the associated tracker object is set to ODEBUG_STATE_ACTIVE."
        },
         {
          "start_index": 18507,
           "end_index": 18624,
           "text": "When the deactivation is legitimate, then the state of the associated tracker object is set to ODEBUG_STATE_INACTIVE."
        },
         {
          "start_index": 19349,
           "end_index": 19466,
           "text": "When the destruction is legitimate, then the state of the associated tracker object is set to ODEBUG_STATE_DESTROYED."
        }
      ]
    },
     {
      "group_id": 7,
       "duplicates": [
        {
          "start_index": 20601,
           "end_index": 20763,
           "text": "Fixup functionsDebug object type description structure fixup_init This function is called from the debug code whenever a problem in debug_object_init is detected."
        },
         {
          "start_index": 21216,
           "end_index": 21331,
           "text": "fixup_activate This function is called from the debug code whenever a problem in debug_object_activate is detected."
        },
         {
          "start_index": 22250,
           "end_index": 22363,
           "text": "fixup_destroy This function is called from the debug code whenever a problem in debug_object_destroy is detected."
        },
         {
          "start_index": 22563,
           "end_index": 22670,
           "text": "fixup_free This function is called from the debug code whenever a problem in debug_object_free is detected."
        },
         {
          "start_index": 23047,
           "end_index": 23168,
           "text": "fixup_assert_init This function is called from the debug code whenever a problem in debug_object_assert_init is detected."
        }
      ]
    },
     {
      "group_id": 8,
       "duplicates": [
        {
          "start_index": 21333,
           "end_index": 21932,
           "text": "Called from debug_object_activate when the object state is: ODEBUG_STATE_NOTAVAILABLEODEBUG_STATE_ACTIVE The function returns 1 when the fixup was successful, otherwise 0. The return value is used to update the statistics. Note that the function needs to call the debug_object_activate() function again after the damage has been repaired in order to keep the state consistent. The activation of statically initialized objects is a special case. When debug_object_activate() has no tracked object for this object address then fixup_activate() is called with object state ODEBUG_STATE_NOTAVAILABLE."
        },
         {
          "start_index": 23309,
           "end_index": 23683,
           "text": "The function returns 1 when the fixup was successful, otherwise 0. The return value is used to update the statistics. Note, this function should make sure debug_object_init() is called before returning. The handling of statically initialized objects is a special case. The fixup function should check if this is a legitimate case of a statically initialized object or not."
        }
      ]
    },
     {
      "group_id": 9,
       "duplicates": [
        {
          "start_index": 21012,
           "end_index": 21062,
           "text": "The return value is used to update the statistics."
        },
         {
          "start_index": 21506,
           "end_index": 21556,
           "text": "The return value is used to update the statistics."
        },
         {
          "start_index": 22512,
           "end_index": 22562,
           "text": "The return value is used to update the statistics."
        },
         {
          "start_index": 22996,
           "end_index": 23046,
           "text": "The return value is used to update the statistics."
        },
         {
          "start_index": 23376,
           "end_index": 23426,
           "text": "The return value is used to update the statistics."
        }
      ]
    },
     {
      "group_id": 10,
       "duplicates": [
        {
          "start_index": 21064,
           "end_index": 21215,
           "text": "Note, that the function needs to call the debug_object_init() function again, after the damage has been repaired in order to keep the state consistent."
        },
         {
          "start_index": 21558,
           "end_index": 21711,
           "text": "Note that the function needs to call the debug_object_activate() function again after the damage has been repaired in order to keep the state consistent."
        }
      ]
    },
     {
      "group_id": 11,
       "duplicates": [
        {
          "start_index": 21933,
           "end_index": 22249,
           "text": "The fixup function needs to check whether this is a legitimate case of a statically initialized object or not. In case it is it calls debug_object_init() and debug_object_activate() to make the object known to the tracker and marked active. In this case the function should return 0 because this is not a real fixup."
        },
         {
          "start_index": 23580,
           "end_index": 23847,
           "text": "The fixup function should check if this is a legitimate case of a statically initialized object or not. In this case only debug_object_init() should be called to make the object known to the tracker. Then the function should return 0 because this is not a real fixup."
        }
      ]
    },
     {
      "group_id": 12,
       "duplicates": [
        {
          "start_index": 22365,
           "end_index": 22511,
           "text": "Called from debug_object_destroy when the object state is: ODEBUG_STATE_ACTIVE The function returns 1 when the fixup was successful, otherwise 0."
        },
         {
          "start_index": 22820,
           "end_index": 22995,
           "text": "Called from debug_object_free() or debug_check_no_obj_freed() when the object state is: ODEBUG_STATE_ACTIVE The function returns 1 when the fixup was successful, otherwise 0."
        },
         {
          "start_index": 23309,
           "end_index": 23375,
           "text": "The function returns 1 when the fixup was successful, otherwise 0."
        }
      ]
    },
     {
      "group_id": 13,
       "duplicates": [
        {
          "start_index": 23848,
           "end_index": 23896,
           "text": "Known Bugs And Assumptions None (knock on wood)."
        },
         {
          "start_index": 34085,
           "end_index": 34117,
           "text": "Known Bugs And Assumptions None."
        },
         {
          "start_index": 161873,
           "end_index": 161921,
           "text": "Known Bugs And Assumptions None (knock on wood)."
        },
         {
          "start_index": 316267,
           "end_index": 316299,
           "text": "Known Bugs And Assumptions None."
        },
         {
          "start_index": 333864,
           "end_index": 333896,
           "text": "Known Bugs And Assumptions None."
        }
      ]
    },
     {
      "group_id": 14,
       "duplicates": [
        {
          "start_index": 23897,
           "end_index": 26330,
           "text": "Linux Device Drivers This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Driver BasicsDriver Entry and Exit points Atomic and pointer manipulation Delaying, scheduling, and timer routines Wait queues and Wake events High-resolution timers Workqueues and Kevents Internal Functions Kernel objects manipulation&lt;!-- X!Iinclude/linux/kobject.h --&gt; Kernel utility functions Device Resource Management Device drivers infrastructureThe Basic Device Driver-Model Structures Device Drivers Base &lt;!-- Cannot be included, because attribute_container_add_class_device_adapter and attribute_container_classdev_to_container exceed allowed 44 characters maximum X!Edrivers/base/attribute_container.c --&gt; &lt;!-- X!Edrivers/base/interface.c --&gt; Device Drivers DMA Management Device Drivers Power Management Device Drivers ACPI Support&lt;!-- Internal functions only X!Edrivers/acpi/sleep/main.c X!Edrivers/acpi/sleep/wakeup.c X!Edrivers/acpi/motherboard.c X!Edrivers/acpi/bus.c --&gt; &lt;!-- No correct structured comments X!Edrivers/acpi/pci_bind.c --&gt; Device drivers PnP support &lt;!-- No correct structured comments X!Edrivers/pnp/system.c --&gt; Userspace IO devices Parallel Port Devices Message-based devicesFusion message devices I2O message devices Sound Devices &lt;!-- FIXME: Removed for now since no structured comments in source X!Isound/sound_firmware.c --&gt; 16x50 UART Driver Frame Buffer Library The frame buffer drivers depend heavily on four data structures. These structures are declared in include/linux/fb.h. They are fb_info, fb_var_screeninfo, fb_fix_screeninfo and fb_monospecs. The last three can be made available to and from userland. fb_info defines the current state of a particular video card."
        },
         {
          "start_index": 366216,
           "end_index": 367466,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction RapidIO is a high speed switched fabric interconnect with features aimed at the embedded market. RapidIO provides support for memory-mapped I/O as well as message-based transactions over the switched fabric network. RapidIO has a standardized discovery mechanism not unlike the PCI bus standard that allows simple detection of devices in a network. This documentation is provided for developers intending to support RapidIO on new architectures, write new drivers, or to understand the subsystem internals. Known Bugs and LimitationsBugsNone."
        }
      ]
    },
     {
      "group_id": 15,
       "duplicates": [
        {
          "start_index": 27348,
           "end_index": 27588,
           "text": "Frame Buffer Memory &lt;!-- &lt;sect1&gt;&lt;title&gt;Frame Buffer Console&lt;/title&gt; X!Edrivers/video/console/fbcon.c &lt;/sect1&gt; --&gt;Frame Buffer Colormap &lt;!-- FIXME: drivers/video/fbgen.c has no docs, which stuffs up the sgml."
        },
         {
          "start_index": 27629,
           "end_index": 27906,
           "text": "KAO &lt;sect1&gt;&lt;title&gt;Frame Buffer Generic Functions&lt;/title&gt; X!Idrivers/video/fbgen.c &lt;/sect1&gt; KAO --&gt;Frame Buffer Video Mode Database Frame Buffer Macintosh Video Mode Database Frame Buffer Fonts Refer to the file lib/fonts/fonts.c for more information."
        }
      ]
    },
     {
      "group_id": 16,
       "duplicates": [
        {
          "start_index": 29303,
           "end_index": 29395,
           "text": "The programming interface is structured around two kinds of driver, and two kinds of device."
        },
         {
          "start_index": 31474,
           "end_index": 31566,
           "text": "The programming interface is structured around two kinds of driver, and two kinds of device."
        }
      ]
    },
     {
      "group_id": 17,
       "duplicates": [
        {
          "start_index": 123055,
           "end_index": 124853,
           "text": "Linux Filesystems API This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. The Linux VFSThe Filesystem types The Directory Cache Inode Handling Registration and Superblocks File Locks Other Functions The proc filesystemsysctl interface proc filesystem interface Events based on file descriptors The Filesystem for Exporting Kernel Objects The debugfs filesystemdebugfs interface The Linux Journalling APIRogerGammansrgammans@computer-surgery.co.ukStephenTweediesct@redhat.com2002Roger GammansThe Linux Journalling APIOverviewDetails The journalling layer is easy to use. You need to first of all create a journal_t data structure. There are two calls to do this dependent on how you decide to allocate the physical media on which the journal resides. The journal_init_inode() call is for journals stored in filesystem inodes, or the journal_init_dev() call can be use for journal stored on a raw device (in a continuous range of blocks). A journal_t is a typedef for a struct pointer, so when you are finally finished make sure you call journal_destroy() on it to free up any used kernel memory."
        },
         {
          "start_index": 174309,
           "end_index": 175805,
           "text": "Unreliable Guide To Hacking The Linux KernelRustyRussellrusty@rustcorp.com.au2005Rusty Russell This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. This is the first release of this document as part of the kernel tarball. Introduction Welcome, gentle reader, to Rusty&#39;s Remarkably Unreliable Guide to Linux Kernel Hacking. This document describes the common routines and general requirements for kernel code: its goal is to serve as a primer for Linux kernel development for experienced C programmers. I avoid implementation details: that&#39;s what the code is for, and I ignore whole tracts of useful routines. Before you read this, please understand that I never wanted to write this document, being grossly under-qualified, but I always wanted to read it, and this was the only way."
        }
      ]
    },
     {
      "group_id": 18,
       "duplicates": [
        {
          "start_index": 37121,
           "end_index": 37453,
           "text": "static inline void qla1280_disable_intrs(struct scsi_qla_host *ha) { struct device_reg *reg; reg = ha-&amp;gt;iobase; /* disable risc and host interrupts */ WRT_REG_WORD(&amp;amp;reg-&amp;gt;ictrl, 0); /* * The following read will ensure that the above write * has been received by the device before we return from this * function."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 19,
       "duplicates": [
        {
          "start_index": 37454,
           "end_index": 37609,
           "text": "*/ RD_REG_WORD(&amp;amp;reg-&amp;gt;ictrl); ha-&amp;gt;flags.ints_enabled = 0; } In addition to write posting, on some large multiprocessing systems (e.g."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 20,
       "duplicates": [
        {
          "start_index": 37725,
           "end_index": 37896,
           "text": "Thus it&#39;s important to properly protect parts of your driver that do memory-mapped writes with locks and use the mmiowb to make sure they arrive in the order intended."
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 21,
       "duplicates": [
        {
          "start_index": 38522,
           "end_index": 38908,
           "text": "CPU A: spin_lock_irqsave(&amp;amp;dev_lock, flags) CPU A: ... CPU A: writel(newval, ring_ptr); CPU A: spin_unlock_irqrestore(&amp;amp;dev_lock, flags) ... CPU B: spin_lock_irqsave(&amp;amp;dev_lock, flags) CPU B: writel(newval2, ring_ptr); CPU B: ... CPU B: spin_unlock_irqrestore(&amp;amp;dev_lock, flags) In the case above, newval2 could be written to ring_ptr before newval."
        },
         {
          "start_index": 38910,
           "end_index": 39621,
           "text": "Fixing it is easy though: CPU A: spin_lock_irqsave(&amp;amp;dev_lock, flags) CPU A: ... CPU A: writel(newval, ring_ptr); CPU A: mmiowb(); /* ensure no other writes beat us to the device */ CPU A: spin_unlock_irqrestore(&amp;amp;dev_lock, flags) ... CPU B: spin_lock_irqsave(&amp;amp;dev_lock, flags) CPU B: writel(newval2, ring_ptr); CPU B: ... CPU B: mmiowb(); CPU B: spin_unlock_irqrestore(&amp;amp;dev_lock, flags) See tg3.c for a real world example of how to use mmiowb PCI ordering rules also guarantee that PIO read responses arrive after any outstanding DMA writes from that bus, since for some devices the result of a readb call may signal to the driver that a DMA transaction is complete."
        }
      ]
    },
     {
      "group_id": 22,
       "duplicates": [
        {
          "start_index": 41151,
           "end_index": 41572,
           "text": "Public Functions Provided Linux DRM Developer&#39;s GuideJesseBarnesInitial versionIntel Corporationjesse.barnes@intel.comLaurentPinchartDriver internalsIdeas on board SPRLlaurent.pinchart@ideasonboard.com2008-20092012Intel CorporationLaurent Pinchart The contents of this file may be used under the terms of the GNU General Public License version 2 (the &quot;GPL&quot;) as distributed in the kernel source COPYING file."
        },
         {
          "start_index": 278442,
           "end_index": 278703,
           "text": "Alternatively, the contents of this file may be used under the terms of the GNU General Public License version 2 (the &quot;GPL&quot;) as distributed in the kernel source COPYING file, in which case the provisions of the GPL are applicable instead of the above."
        }
      ]
    },
     {
      "group_id": 23,
       "duplicates": [
        {
          "start_index": 45443,
           "end_index": 45571,
           "text": "The information is printed to the kernel log at initialization time and passed to userspace through the DRM_IOCTL_VERSION ioctl."
        },
         {
          "start_index": 46629,
           "end_index": 46756,
           "text": "The DRM core prints it to the kernel log at initialization time and passes it to userspace through the DRM_IOCTL_VERSION ioctl."
        }
      ]
    },
     {
      "group_id": 24,
       "duplicates": [
        {
          "start_index": 49755,
           "end_index": 49905,
           "text": "The operation is optional and must make sure that the interrupt will not get fired by clearing all pending interrupt flags or disabling the interrupt."
        },
         {
          "start_index": 81141,
           "end_index": 81167,
           "text": "The operation is optional."
        }
      ]
    },
     {
      "group_id": 25,
       "duplicates": [
        {
          "start_index": 60863,
           "end_index": 60973,
           "text": "That operation is mandatory for GEM-enabled drivers and must free the GEM object and all associated resources."
        },
         {
          "start_index": 100494,
           "end_index": 100522,
           "text": "This operation is mandatory."
        },
         {
          "start_index": 100775,
           "end_index": 100803,
           "text": "This operation is mandatory."
        },
         {
          "start_index": 104144,
           "end_index": 104172,
           "text": "This operation is mandatory."
        }
      ]
    },
     {
      "group_id": 26,
       "duplicates": [
        {
          "start_index": 66224,
           "end_index": 66355,
           "text": "The function allocates a fake offset range from a pool and stores the offset divided by PAGE_SIZE in obj-&amp;gt;map_list.hash.key."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 27,
       "duplicates": [
        {
          "start_index": 66474,
           "end_index": 66536,
           "text": "This can be tested by obj-&amp;gt;map_list.map being non-NULL."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 28,
       "duplicates": [
        {
          "start_index": 66538,
           "end_index": 66744,
           "text": "Once allocated, the fake offset value (obj-&amp;gt;map_list.hash.key &amp;lt;&amp;lt; PAGE_SHIFT) must be passed to the application in a driver-specific way and can then be used as the mmap offset argument."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 29,
       "duplicates": [
        {
          "start_index": 69991,
           "end_index": 70279,
           "text": "This core CPU&amp;lt;-&amp;gt;GPU coherency management is provided by a device-specific ioctl, which evaluates an object&#39;s current domain and performs any necessary flushing or synchronization to put the object into the desired coherency domain (note that the object may be busy, i.e."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 30,
       "duplicates": [
        {
          "start_index": 77333,
           "end_index": 77502,
           "text": "The instance is allocated and zeroed by the driver, possibly as part of a larger structure, and registered with a call to drm_crtc_init with a pointer to CRTC functions."
        },
         {
          "start_index": 83722,
           "end_index": 83813,
           "text": "The instance is allocated and zeroed by the driver, possibly as part of a larger structure."
        }
      ]
    },
     {
      "group_id": 31,
       "duplicates": [
        {
          "start_index": 77995,
           "end_index": 78051,
           "text": "This operation is called with the mode config lock held."
        },
         {
          "start_index": 78333,
           "end_index": 78390,
           "text": "This operation is called with the mode config mutex held."
        }
      ]
    },
     {
      "group_id": 32,
       "duplicates": [
        {
          "start_index": 80051,
           "end_index": 80467,
           "text": "This can be performed with spin_lock_irqsave(&amp;amp;dev-&amp;gt;event_lock, flags); ... drm_send_vblank_event(dev, pipe, event); spin_unlock_irqrestore(&amp;amp;dev-&amp;gt;event_lock, flags); FIXME: Could drivers that don&#39;t need to wait for rendering to complete just add the event to dev-&amp;gt;vblank_event_list and let the DRM core handle everything, as for &quot;normal&quot; vertical blanking events?"
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 284018,
           "end_index": 284061,
           "text": "Most drivers don&#39;t need to define this."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 491008,
           "end_index": 491072,
           "text": "Above all, you&#39;ll need to define this in the open callback."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 33,
       "duplicates": [
        {
          "start_index": 80469,
           "end_index": 80638,
           "text": "While waiting for the page flip to complete, the event-&amp;gt;base.link list head can be used freely by the driver to store the pending event in a driver-specific list."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 34,
       "duplicates": [
        {
          "start_index": 80810,
           "end_index": 81008,
           "text": "Miscellaneousvoid (*set_property)(struct drm_crtc *crtc, struct drm_property *property, uint64_t value); Set the value of the given CRTC property to value. See for more information about properties."
        },
         {
          "start_index": 84921,
           "end_index": 85109,
           "text": "void (*set_property)(struct drm_plane *plane, struct drm_property *property, uint64_t value); Set the value of the given plane property to value. See for more information about properties."
        },
         {
          "start_index": 90644,
           "end_index": 90857,
           "text": "Miscellaneousvoid (*set_property)(struct drm_connector *connector, struct drm_property *property, uint64_t value); Set the value of the given connector property to value. See for more information about properties."
        }
      ]
    },
     {
      "group_id": 35,
       "duplicates": [
        {
          "start_index": 84921,
           "end_index": 85066,
           "text": "void (*set_property)(struct drm_plane *plane, struct drm_property *property, uint64_t value); Set the value of the given plane property to value."
        },
         {
          "start_index": 90644,
           "end_index": 90814,
           "text": "Miscellaneousvoid (*set_property)(struct drm_connector *connector, struct drm_property *property, uint64_t value); Set the value of the given connector property to value."
        }
      ]
    },
     {
      "group_id": 36,
       "duplicates": [
        {
          "start_index": 86255,
           "end_index": 86412,
           "text": "polled Connector polling mode, a combination of DRM_CONNECTOR_POLL_HPD The connector generates hotplug events and doesn&#39;t need to be periodically polled."
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 37,
       "duplicates": [
        {
          "start_index": 91618,
           "end_index": 92280,
           "text": "Output discovery and initialization example void intel_crt_init(struct drm_device *dev) { struct drm_connector *connector; struct intel_output *intel_output; intel_output = kzalloc(sizeof(struct intel_output), GFP_KERNEL); if (!intel_output) return; connector = &amp;amp;intel_output-&amp;gt;base; drm_connector_init(dev, &amp;amp;intel_output-&amp;gt;base, &amp;amp;intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA); drm_encoder_init(dev, &amp;amp;intel_output-&amp;gt;enc, &amp;amp;intel_crt_enc_funcs, DRM_MODE_ENCODER_DAC); drm_mode_connector_attach_encoder(&amp;amp;intel_output-&amp;gt;base, &amp;amp;intel_output-&amp;gt;enc); /* Set up the DDC bus."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 38,
       "duplicates": [
        {
          "start_index": 92281,
           "end_index": 92981,
           "text": "*/ intel_output-&amp;gt;ddc_bus = intel_i2c_create(dev, GPIOA, &quot;CRTDDC_A&quot;); if (!intel_output-&amp;gt;ddc_bus) { dev_printk(KERN_ERR, &amp;amp;dev-&amp;gt;pdev-&amp;gt;dev, &quot;DDC bus registration &quot; &quot;failed.\\n&quot;); return; } intel_output-&amp;gt;type = INTEL_OUTPUT_ANALOG; connector-&amp;gt;interlace_allowed = 0; connector-&amp;gt;doublescan_allowed = 0; drm_encoder_helper_add(&amp;amp;intel_output-&amp;gt;enc, &amp;amp;intel_crt_helper_funcs); drm_connector_helper_add(connector, &amp;amp;intel_crt_connector_helper_funcs); drm_sysfs_connector_add(connector); } In the example above (taken from the i915 driver), a CRTC, connector and encoder combination is created."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 39,
       "duplicates": [
        {
          "start_index": 93387,
           "end_index": 93498,
           "text": "They&#39;re called by the DRM core and ioctl handlers to handle device state changes and configuration request."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 40,
       "duplicates": [
        {
          "start_index": 96971,
           "end_index": 97369,
           "text": "CRTC Helper Operationsbool (*mode_fixup)(struct drm_crtc *crtc, const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode); Let CRTCs adjust the requested mode or reject it completely. This operation returns true if the mode is accepted (possibly after being adjusted) or false if it is rejected. The mode_fixup operation should reject the mode if it can&#39;t reasonably use it."
        },
         {
          "start_index": 99109,
           "end_index": 99523,
           "text": "Encoder Helper Operationsbool (*mode_fixup)(struct drm_encoder *encoder, const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode); Let encoders adjust the requested mode or reject it completely. This operation returns true if the mode is accepted (possibly after being adjusted) or false if it is rejected. See the mode_fixup CRTC helper operation for an explanation of the allowed adjustments."
        }
      ]
    },
     {
      "group_id": 41,
       "duplicates": [
        {
          "start_index": 97740,
           "end_index": 97918,
           "text": "int (*mode_set_base)(struct drm_crtc *crtc, int x, int y, struct drm_framebuffer *old_fb) Move the CRTC on the current frame buffer (stored in crtc-&amp;gt;fb) to position (x,y)."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 42,
       "duplicates": [
        {
          "start_index": 98136,
           "end_index": 98246,
           "text": "FIXME: Why are x and y passed as arguments, as they can be accessed through crtc-&amp;gt;x and crtc-&amp;gt;y?"
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 43,
       "duplicates": [
        {
          "start_index": 98322,
           "end_index": 99108,
           "text": "This operation is called after validating the requested mode. Drivers use it to perform device-specific operations required before setting the new mode. int (*mode_set)(struct drm_crtc *crtc, struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode, int x, int y, struct drm_framebuffer *old_fb); Set a new mode, position and frame buffer. Depending on the device requirements, the mode can be stored internally by the driver and applied in the commit operation, or programmed to the hardware immediately. The mode_set operation returns 0 on success or a negative error code if an error occurs. void (*commit)(struct drm_crtc *crtc); Commit a mode. This operation is called after setting the new mode. Upon return the device must use the new mode and be fully operational."
        },
         {
          "start_index": 99608,
           "end_index": 100397,
           "text": "This operation is called after validating the requested mode. Drivers use it to perform device-specific operations required before setting the new mode. void (*mode_set)(struct drm_encoder *encoder, struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode); Set a new mode. Depending on the device requirements, the mode can be stored internally by the driver and applied in the commit operation, or programmed to the hardware immediately. void (*commit)(struct drm_encoder *encoder); Commit a mode. This operation is called after setting the new mode. Upon return the device must use the new mode and be fully operational. Connector Helper Operationsstruct drm_encoder *(*best_encoder)(struct drm_connector *connector); Return a pointer to the best encoder for the connecter."
        }
      ]
    },
     {
      "group_id": 44,
       "duplicates": [
        {
          "start_index": 101436,
           "end_index": 102825,
           "text": "__u32 clock;Pixel clock frequency in kHz unit__u16 hdisplay, hsync_start, hsync_end, htotal; __u16 vdisplay, vsync_start, vsync_end, vtotal;Horizontal and vertical timing information Active Front Sync Back Region Porch Porch &amp;lt;-----------------------&amp;gt;&amp;lt;----------------&amp;gt;&amp;lt;-------------&amp;gt;&amp;lt;--------------&amp;gt; //////////////////////| ////////////////////// | ////////////////////// |.................. ................ _______________ &amp;lt;----- [hv]display -----&amp;gt; &amp;lt;------------- [hv]sync_start ------------&amp;gt; &amp;lt;--------------------- [hv]sync_end ---------------------&amp;gt; &amp;lt;-------------------------------- [hv]total -----------------------------&amp;gt; __u16 hskew; __u16 vscan;Unknown__u32 flags; Mode flags, a combination of DRM_MODE_FLAG_PHSYNC Horizontal sync is active high DRM_MODE_FLAG_NHSYNC Horizontal sync is active low DRM_MODE_FLAG_PVSYNC Vertical sync is active high DRM_MODE_FLAG_NVSYNC Vertical sync is active low DRM_MODE_FLAG_INTERLACE Mode is interlaced DRM_MODE_FLAG_DBLSCAN Mode uses doublescan DRM_MODE_FLAG_CSYNC Mode uses composite sync DRM_MODE_FLAG_PCSYNC Composite sync is active high DRM_MODE_FLAG_NCSYNC Composite sync is active low DRM_MODE_FLAG_HSKEW hskew provided (not used?)"
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 45,
       "duplicates": [
        {
          "start_index": 103521,
           "end_index": 103764,
           "text": "When creating modes manually the get_modes helper operation must set the display_info width_mm and height_mm fields if they haven&#39;t been set already (for instance at initilization time when a fixed-size panel is attached to the connector)."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 46,
       "duplicates": [
        {
          "start_index": 107041,
           "end_index": 107420,
           "text": "struct drm_property *drm_property_create_range(struct drm_device *dev, int flags, const char *name, uint64_t min, uint64_t max);Create a range property with the given minimum and maximum values.struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags, const char *name, const struct drm_prop_enum_list *props, int num_values);Create an enumerated property."
        },
         {
          "start_index": 107421,
           "end_index": 107674,
           "text": "The props argument points to an array of num_values value-name pairs.struct drm_property *drm_property_create_bitmask(struct drm_device *dev, int flags, const char *name, const struct drm_prop_enum_list *props, int num_values);Create a bitmask property."
        },
         {
          "start_index": 107421,
           "end_index": 107490,
           "text": "The props argument points to an array of num_values value-name pairs."
        }
      ]
    },
     {
      "group_id": 47,
       "duplicates": [
        {
          "start_index": 118124,
           "end_index": 118249,
           "text": "- crtc and connector .save and .restore operations are only used internally in drivers, should they be removed from the core?"
        },
         {
          "start_index": 118250,
           "end_index": 118374,
           "text": "- encoder mid-layer .save and .restore operations are only used internally in drivers, should they be removed from the core?"
        },
         {
          "start_index": 118375,
           "end_index": 118484,
           "text": "- encoder mid-layer .detect operation is only used internally in drivers, should it be removed from the core?"
        }
      ]
    },
     {
      "group_id": 48,
       "duplicates": [
        {
          "start_index": 119347,
           "end_index": 119417,
           "text": "The primary node is always created and called card&amp;lt;num&amp;gt;."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 49,
       "duplicates": [
        {
          "start_index": 119418,
           "end_index": 119516,
           "text": "Additionally, a currently unused control node, called controlD&amp;lt;num&amp;gt; is also created."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 50,
       "duplicates": [
        {
          "start_index": 120544,
           "end_index": 120666,
           "text": "If a driver advertises render node support, DRM core will create a separate render node called renderD&amp;lt;num&amp;gt;."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 51,
       "duplicates": [
        {
          "start_index": 125842,
           "end_index": 125998,
           "text": "Or isn&#39;t a good idea for the journal layer to hide dirty mounts from the client fs] Now you can go ahead and start modifying the underlying filesystem."
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 52,
       "duplicates": [
        {
          "start_index": 127239,
           "end_index": 127449,
           "text": "Or if you&#39;ve asked for access to a buffer you now know is now longer required to be pushed back on the device you can call journal_forget() in much the same way as you might have used bforget() in the past."
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 53,
       "duplicates": [
        {
          "start_index": 132282,
           "end_index": 133709,
           "text": "USB Gadget API for Linux20 August 200420 August 2004 This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. 2003-2004David BrownellDavidBrownelldbrownell@users.sourceforge.netIntroductionThis document presents a Linux-USB &quot;Gadget&quot; kernel mode API, for use within peripherals and other USB devices that embed Linux. It provides an overview of the API structure, and shows how that fits into a system development project. This is the first such API released on Linux to address a number of important problems, including: Supports USB 2.0, for high speed devices which can stream data at several dozen megabytes per second. Handles devices with dozens of endpoints just as well as ones with just two fixed-function ones."
        },
         {
          "start_index": 169811,
           "end_index": 171263,
           "text": "Credits The following people have contributed to this document: Thomas Gleixnertglx@linutronix.deIngo Molnarmingo@elte.hu The Linux Kernel API This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Data TypesDoubly Linked Lists Basic C Library Functions When writing drivers, you cannot in general use routines which are from the C Library. Some of the functions have been found generally useful and they are listed below. The behaviour of these functions may vary slightly from those defined by ANSI, and these deviations are noted in the text. String Conversions String Manipulation&lt;!-- All functions are exported at now X!Ilib/string.c --&gt; Bit Operations Basic Kernel Library Functions The Linux kernel provides more basic utility functions."
        },
         {
          "start_index": 202692,
           "end_index": 203949,
           "text": "Unreliable Guide To LockingRustyRussellrusty@rustcorp.com.au2003Rusty Russell This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction Welcome, to Rusty&#39;s Remarkably Unreliable Guide to Kernel Locking issues. This document describes the locking systems in the Linux Kernel in 2.6. With the wide availability of HyperThreading, and preemption in the Linux Kernel, everyone hacking on the kernel needs to know the fundamentals of concurrency and locking for SMP. The Problem With Concurrency (Skip this if you know what a Race Condition is)."
        },
         {
          "start_index": 415247,
           "end_index": 416677,
           "text": "Linutronix homepage.The Linux-USB Host Side API This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction to USB on LinuxA Universal Serial Bus (USB) is used to connect a host, such as a PC or workstation, to a number of peripheral devices. USB uses a tree structure, with the host as the root (the system&#39;s master), hubs as interior nodes, and peripherals as leaves (and slaves). Modern PCs support several such trees of USB devices, usually one USB 2.0 tree (480 Mbit/sec each) with a few USB 1.1 trees (12 Mbit/sec each) that are used when you connect a USB 1.1 device directly to the machine&#39;s &quot;root hub&quot;. That master/slave asymmetry was designed-in for a number of reasons, one being ease of use."
        }
      ]
    },
     {
      "group_id": 54,
       "duplicates": [
        {
          "start_index": 136357,
           "end_index": 136454,
           "text": "The &amp;lt;linux/usb/gadget.h&amp;gt; API abstracts the peripheral controller endpoint hardware."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 55,
       "duplicates": [
        {
          "start_index": 139295,
           "end_index": 139526,
           "text": "OTG-capable systems will also need to include a standard Linux-USB host side stack, with usbcore, one or more Host Controller Drivers (HCDs), USB Device Drivers to support the OTG &quot;Targeted Peripheral List&quot;, and so forth."
        },
         {
          "start_index": 156057,
           "end_index": 156147,
           "text": "Also on the host side, a driver must support the OTG &quot;Targeted Peripheral List&quot;."
        }
      ]
    },
     {
      "group_id": 56,
       "duplicates": [
        {
          "start_index": 140494,
           "end_index": 140623,
           "text": "Most such USB protocol code doesn&#39;t need to be hardware-specific, any more than network protocols like X11, HTTP, or NFS are."
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 57,
       "duplicates": [
        {
          "start_index": 141733,
           "end_index": 141874,
           "text": "You&#39;ll have to read the header file, and use example source code (such as that for &quot;Gadget Zero&quot;), to fully understand the API."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 58,
       "duplicates": [
        {
          "start_index": 147802,
           "end_index": 147997,
           "text": "USB 2.0 Chapter 9 Types and ConstantsGadget drivers rely on common USB structures and constants defined in the &amp;lt;linux/usb/ch9.h&amp;gt; header file, which is standard in Linux 2.6 kernels."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 515430,
           "end_index": 515492,
           "text": "The control API is defined in &amp;lt;sound/control.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        },
         {
          "start_index": 526845,
           "end_index": 526913,
           "text": "The AC97 codec API is defined in &amp;lt;sound/ac97_codec.h&amp;gt;."
        },
         {
          "start_index": 532638,
           "end_index": 532703,
           "text": "The MPU401-UART API is defined in &amp;lt;sound/mpu401.h&amp;gt;."
        },
         {
          "start_index": 536469,
           "end_index": 536531,
           "text": "The rawmidi API is defined in &amp;lt;sound/rawmidi.h&amp;gt;."
        },
         {
          "start_index": 542554,
           "end_index": 542610,
           "text": "The OPL3 API is defined in &amp;lt;sound/opl3.h&amp;gt;."
        },
         {
          "start_index": 544914,
           "end_index": 544972,
           "text": "The hwdep API is defined in &amp;lt;sound/hwdep.h&amp;gt;."
        }
      ]
    },
     {
      "group_id": 59,
       "duplicates": [
        {
          "start_index": 148080,
           "end_index": 148244,
           "text": "Core Objects and MethodsThese are declared in &amp;lt;linux/usb/gadget.h&amp;gt;, and are used by gadget drivers to interact with USB peripheral controller drivers."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 60,
       "duplicates": [
        {
          "start_index": 151387,
           "end_index": 151505,
           "text": "Support for other controllers is expected to be developed and contributed over time, as this driver framework evolves."
        },
         {
          "start_index": 154168,
           "end_index": 154290,
           "text": "Support for other kinds of gadget is expected to be developed and contributed over time, as this driver framework evolves."
        }
      ]
    },
     {
      "group_id": 61,
       "duplicates": [
        {
          "start_index": 156149,
           "end_index": 156247,
           "text": "That&#39;s just a whitelist, used to reject peripherals not supported with a given Linux OTG host."
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 62,
       "duplicates": [
        {
          "start_index": 157691,
           "end_index": 158761,
           "text": "&lt;!-- vim:syntax=sgml:sw=4 --&gt;Linux generic IRQ handlingThomasGleixnertglx@linutronix.deIngoMolnarmingo@elte.hu2005-2010Thomas Gleixner2005-2006Ingo Molnar This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction The generic interrupt handling layer is designed to provide a complete abstraction of interrupt handling for device drivers. It is able to handle all the different types of interrupt controller hardware."
        },
         {
          "start_index": 572401,
           "end_index": 573542,
           "text": "Writing USB Device DriversGregKroah-Hartmangreg@kroah.com2001-2002Greg Kroah-Hartman This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. This documentation is based on an article published in Linux Journal Magazine, October 2001, Issue 90. Introduction The Linux USB subsystem has grown from supporting only two different types of devices in the 2.2.7 kernel (mice and keyboards), to over 20 different types of devices in the 2.4 kernel."
        }
      ]
    },
     {
      "group_id": 63,
       "duplicates": [
        {
          "start_index": 159949,
           "end_index": 160070,
           "text": "The original general IRQ implementation used hw_interrupt_type structures and their -&amp;gt;ack(), -&amp;gt;end() [etc.]"
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 64,
       "duplicates": [
        {
          "start_index": 161808,
           "end_index": 161872,
           "text": "It&#39;s deprecated for three years now and about to be removed."
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 65,
       "duplicates": [
        {
          "start_index": 162525,
           "end_index": 162664,
           "text": "Whenever an interrupt triggers, the low-level architecture code calls into the generic interrupt code by calling desc-&amp;gt;handle_irq()."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 66,
       "duplicates": [
        {
          "start_index": 162665,
           "end_index": 162804,
           "text": "This high-level IRQ handling function only uses desc-&amp;gt;irq_data.chip primitives referenced by the assigned chip descriptor structure."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 67,
       "duplicates": [
        {
          "start_index": 165022,
           "end_index": 165746,
           "text": "The following control flow is implemented (simplified excerpt): if (desc-&amp;gt;status &amp;amp; running) { desc-&amp;gt;irq_data.chip-&amp;gt;irq_mask_ack(); desc-&amp;gt;status |= pending | masked; return; } desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack(); desc-&amp;gt;status |= running; do { if (desc-&amp;gt;status &amp;amp; masked) desc-&amp;gt;irq_data.chip-&amp;gt;irq_unmask(); desc-&amp;gt;status &amp;amp;= ~pending; handle_irq_event(desc-&amp;gt;action); } while (status &amp;amp; pending); desc-&amp;gt;status &amp;amp;= ~running; Default simple IRQ flow handler handle_simple_irq provides a generic implementation for simple interrupts. Note: The simple flow handler does not call any handler/chip primitives."
        },
         {
          "start_index": 166068,
           "end_index": 166794,
           "text": "The following control flow is implemented (simplified excerpt): if (desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack) desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack(); handle_irq_event(desc-&amp;gt;action); if (desc-&amp;gt;irq_data.chip-&amp;gt;irq_eoi) desc-&amp;gt;irq_data.chip-&amp;gt;irq_eoi(); EOI Edge IRQ flow handler handle_edge_eoi_irq provides an abnomination of the edge handler which is solely used to tame a badly wreckaged irq controller on powerpc/cell. Bad IRQ flow handler handle_bad_irq is used for spurious interrupts which have no real handler assigned.. Quirks and optimizations The generic functions are intended for &#39;clean&#39; architectures and chips, which have no platform-specific IRQ handling quirks."
        }
      ]
    },
     {
      "group_id": 68,
       "duplicates": [
        {
          "start_index": 164400,
           "end_index": 164757,
           "text": "The following control flow is implemented (simplified excerpt): desc-&amp;gt;irq_data.chip-&amp;gt;irq_mask_ack(); handle_irq_event(desc-&amp;gt;action); desc-&amp;gt;irq_data.chip-&amp;gt;irq_unmask(); Default Fast EOI IRQ flow handler handle_fasteoi_irq provides a generic implementation for interrupts, which only need an EOI at the end of the handler."
        },
         {
          "start_index": 164759,
           "end_index": 165020,
           "text": "The following control flow is implemented (simplified excerpt): handle_irq_event(desc-&amp;gt;action); desc-&amp;gt;irq_data.chip-&amp;gt;irq_eoi(); Default Edge IRQ flow handler handle_edge_irq provides a generic implementation for edge-triggered interrupts."
        },
         {
          "start_index": 165022,
           "end_index": 165672,
           "text": "The following control flow is implemented (simplified excerpt): if (desc-&amp;gt;status &amp;amp; running) { desc-&amp;gt;irq_data.chip-&amp;gt;irq_mask_ack(); desc-&amp;gt;status |= pending | masked; return; } desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack(); desc-&amp;gt;status |= running; do { if (desc-&amp;gt;status &amp;amp; masked) desc-&amp;gt;irq_data.chip-&amp;gt;irq_unmask(); desc-&amp;gt;status &amp;amp;= ~pending; handle_irq_event(desc-&amp;gt;action); } while (status &amp;amp; pending); desc-&amp;gt;status &amp;amp;= ~running; Default simple IRQ flow handler handle_simple_irq provides a generic implementation for simple interrupts."
        },
         {
          "start_index": 165748,
           "end_index": 165957,
           "text": "The following control flow is implemented (simplified excerpt): handle_irq_event(desc-&amp;gt;action); Default per CPU flow handler handle_percpu_irq provides a generic implementation for per CPU interrupts."
        },
         {
          "start_index": 166068,
           "end_index": 166530,
           "text": "The following control flow is implemented (simplified excerpt): if (desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack) desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack(); handle_irq_event(desc-&amp;gt;action); if (desc-&amp;gt;irq_data.chip-&amp;gt;irq_eoi) desc-&amp;gt;irq_data.chip-&amp;gt;irq_eoi(); EOI Edge IRQ flow handler handle_edge_eoi_irq provides an abnomination of the edge handler which is solely used to tame a badly wreckaged irq controller on powerpc/cell."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 69,
       "duplicates": [
        {
          "start_index": 167715,
           "end_index": 167896,
           "text": "(It&#39;s necessary to enable CONFIG_HARDIRQS_SW_RESEND when you want to use the delayed interrupt disable feature and your hardware is not capable of retriggering an interrupt.)"
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 440664,
           "end_index": 440699,
           "text": "(That&#39;s not usually a problem.)"
        },
         {
          "start_index": 442844,
           "end_index": 442893,
           "text": "(It&#39;s usually a pointer to per-request data.)"
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 70,
       "duplicates": [
        {
          "start_index": 169062,
           "end_index": 169141,
           "text": "The per-irq structure is protected via desc-&amp;gt;lock, by the generic layer."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 71,
       "duplicates": [
        {
          "start_index": 169572,
           "end_index": 169699,
           "text": "Public Functions Provided This chapter contains the autogenerated documentation of the kernel API functions which are exported."
        },
         {
          "start_index": 169701,
           "end_index": 169809,
           "text": "Internal Functions Provided This chapter contains the autogenerated documentation of the internal functions."
        },
         {
          "start_index": 320525,
           "end_index": 320654,
           "text": "Public Functions Provided This chapter contains the autogenerated documentation of the Reed-Solomon functions which are exported."
        },
         {
          "start_index": 363800,
           "end_index": 363932,
           "text": "Public Functions Provided This chapter contains the autogenerated documentation of the NAND kernel API functions which are exported."
        },
         {
          "start_index": 364082,
           "end_index": 364202,
           "text": "Internal Functions Provided This chapter contains the autogenerated documentation of the NAND driver internal functions."
        }
      ]
    },
     {
      "group_id": 72,
       "duplicates": [
        {
          "start_index": 364791,
           "end_index": 366399,
           "text": "The following people have contributed to this document: Thomas Gleixnertglx@linutronix.de Linux Networking and Network Devices APIs This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Linux NetworkingNetworking Base Types Socket Buffer Functions Socket Filter Generic Network Statistics SUN RPC subsystem&lt;!-- The !D functionality is not perfect, garbage has to be protected by comments --&gt; WiMAX Network device supportDriver Support PHY Support &lt;!-- FIXME: Removed for now since no structured comments in source &lt;sect1&gt;&lt;title&gt;Wireless&lt;/title&gt; X!Enet/core/wireless.c &lt;/sect1&gt; --&gt;RapidIO Subsystem GuideMattPortermporter@kernel.crashing.orgmporter@mvista.com2005MontaVista Software, Inc. This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 445144,
           "end_index": 446236,
           "text": "Copyright (c) 2002-2005 Takashi Iwai tiwai@suse.de This document is free; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This document is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA &lt;!-- ****************************************************** --&gt;&lt;!-- Preface --&gt;&lt;!-- ****************************************************** --&gt;Preface This document describes how to write an ALSA (Advanced Linux Sound Architecture) driver. The document focuses mainly on PCI soundcards. In the case of other device types, the API might be different, too."
        }
      ]
    },
     {
      "group_id": 73,
       "duplicates": [
        {
          "start_index": 176543,
           "end_index": 176650,
           "text": "We&#39;ll see a number of ways that the user context can block interrupts, to become truly non-preemptable."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 74,
       "duplicates": [
        {
          "start_index": 177557,
           "end_index": 177728,
           "text": "Because it disables interrupts, this handler has to be fast: frequently it simply acknowledges the interrupt, marks a &#39;software interrupt&#39; for execution and exits."
        },
         {
          "start_index": 247907,
           "end_index": 247990,
           "text": "Tasklets and softirqs both fall into the category of &#39;software interrupts&#39;."
        }
      ]
    },
     {
      "group_id": 75,
       "duplicates": [
        {
          "start_index": 177894,
           "end_index": 178158,
           "text": "Software Interrupt Context: Softirqs and Tasklets Whenever a system call is about to return to userspace, or a hardware interrupt handler exits, any &#39;software interrupts&#39; which are marked pending (usually by hardware interrupts) are run (kernel/softirq.c)."
        },
         {
          "start_index": 247907,
           "end_index": 247990,
           "text": "Tasklets and softirqs both fall into the category of &#39;software interrupts&#39;."
        }
      ]
    },
     {
      "group_id": 76,
       "duplicates": [
        {
          "start_index": 179582,
           "end_index": 179639,
           "text": "Are you sure you can&#39;t do what you want in userspace?"
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 77,
       "duplicates": [
        {
          "start_index": 180344,
           "end_index": 180400,
           "text": "The Linux kernel is portable Let&#39;s keep it that way."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 78,
       "duplicates": [
        {
          "start_index": 180679,
           "end_index": 180950,
           "text": "ioctls: Not writing a new system call A system call generally looks like this asmlinkage long sys_mycall(int arg) { return 0; } First, in most cases you don&#39;t want to create a new system call. You create a character device and implement an appropriate ioctl for it."
        },
         {
          "start_index": 185474,
           "end_index": 185549,
           "text": "If you don&#39;t know what that is you don&#39;t need it. Very unreliable."
        }
      ]
    },
     {
      "group_id": 79,
       "duplicates": [
        {
          "start_index": 181876,
           "end_index": 181990,
           "text": "if (signal_pending(current)) return -ERESTARTSYS; If you&#39;re doing longer computations: first think userspace."
        },
         {
          "start_index": 185474,
           "end_index": 185531,
           "text": "If you don&#39;t know what that is you don&#39;t need it."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 80,
       "duplicates": [
        {
          "start_index": 182576,
           "end_index": 182731,
           "text": "Note that some functions may sleep implicitly: common ones are the user space access functions (*_user) and memory allocation functions without GFP_ATOMIC."
        },
         {
          "start_index": 184742,
           "end_index": 184777,
           "text": "The functions may sleep implicitly."
        }
      ]
    },
     {
      "group_id": 81,
       "duplicates": [
        {
          "start_index": 183517,
           "end_index": 183711,
           "text": "Special case: for printing an IP address use __be32 ipaddress; printk(KERN_INFO &quot;my ip: %pI4\\n&quot;, &amp;amp;ipaddress); printk() internally uses a 1K buffer and does not catch overruns."
        },
         {
          "start_index": 301609,
           "end_index": 301663,
           "text": "!BSY &amp;amp;&amp;amp; !DRQ during PIO data transfer."
        },
         {
          "start_index": 301693,
           "end_index": 301794,
           "text": "!BSY &amp;amp;&amp;amp; ERR after CDB transfer starts but before the last byte of CDB is transferred."
        },
         {
          "start_index": 302888,
           "end_index": 303014,
           "text": "For ATA commands, this type of errors are indicated by !BSY &amp;amp;&amp;amp; ERR during command execution and on completion."
        },
         {
          "start_index": 303015,
           "end_index": 303188,
           "text": "For ATAPI commands, !BSY &amp;amp;&amp;amp; ERR &amp;amp;&amp;amp; ABRT right after issuing PACKET indicates that PACKET command is not supported and falls in this category."
        },
         {
          "start_index": 303190,
           "end_index": 303356,
           "text": "!BSY &amp;amp;&amp;amp; ERR(==CHK) &amp;amp;&amp;amp; !ABRT after the last byte of CDB is transferred indicates CHECK CONDITION and doesn&#39;t fall in this category."
        },
         {
          "start_index": 303358,
           "end_index": 303534,
           "text": "!BSY &amp;amp;&amp;amp; ERR(==CHK) &amp;amp;&amp;amp; ABRT after the last byte of CDB is transferred *probably* indicates CHECK CONDITION and doesn&#39;t fall in this category."
        }
      ]
    },
     {
      "group_id": 82,
       "duplicates": [
        {
          "start_index": 186117,
           "end_index": 186169,
           "text": "It&#39;ll allocate virtual memory in the kernel map."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 83,
       "duplicates": [
        {
          "start_index": 195585,
           "end_index": 195679,
           "text": "If you don&#39;t have some particular pressing need for a single list, it&#39;s a good choice."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 84,
       "duplicates": [
        {
          "start_index": 200752,
           "end_index": 200775,
           "text": "\\ ((n) &amp;gt; 20000 ?"
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 85,
       "duplicates": [
        {
          "start_index": 201118,
           "end_index": 201405,
           "text": "*/ #define ERR_PTR(err) ((void *)((long)(err))) #define PTR_ERR(ptr) ((long)(ptr)) #define IS_ERR(ptr) ((unsigned long)(ptr) &amp;gt; (unsigned long)(-1000)) arch/x86/include/asm/uaccess_32.h: #define copy_to_user(to,from,n) \\ (__builtin_constant_p(n) ?"
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 86,
       "duplicates": [
        {
          "start_index": 377842,
           "end_index": 378658,
           "text": "SCSI Interfaces GuideJamesBottomleyJames.Bottomley@hansenpartnership.comRobLandleyrob@landley.net2007Linux Foundation This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. For more details see the file COPYING in the source distribution of Linux. IntroductionProtocol vs bus Once upon a time, the Small Computer Systems Interface defined both a parallel I/O bus and a data protocol to connect a wide variety of peripherals (disk drives, tape drives, modems, printers, scanners, optical drives, test equipment, and medical devices) to a host computer."
        },
         {
          "start_index": 386014,
           "end_index": 386706,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        }
      ]
    },
     {
      "group_id": 87,
       "duplicates": [
        {
          "start_index": 206215,
           "end_index": 206320,
           "text": "If you can&#39;t lock a mutex, your task will suspend itself, and be woken up when the mutex is released."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 88,
       "duplicates": [
        {
          "start_index": 208657,
           "end_index": 208776,
           "text": "(The &#39;_bh&#39; suffix is a historical reference to &quot;Bottom Halves&quot;, the old name for software interrupts."
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 89,
       "duplicates": [
        {
          "start_index": 208971,
           "end_index": 209156,
           "text": "This works perfectly for UP as well: the spin lock vanishes, and this macro simply becomes local_bh_disable() (include/linux/interrupt.h), which protects you from the softirq being run."
        },
         {
          "start_index": 211593,
           "end_index": 211782,
           "text": "This works perfectly for UP as well: the spin lock vanishes, and this macro simply becomes local_irq_disable() (include/asm/smp.h), which protects you from the softirq/tasklet/BH being run."
        }
      ]
    },
     {
      "group_id": 90,
       "duplicates": [
        {
          "start_index": 210259,
           "end_index": 210391,
           "text": "If you&#39;re going so far as to use a softirq, you probably care about scalable performance enough to justify the extra complexity."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 91,
       "duplicates": [
        {
          "start_index": 210393,
           "end_index": 210462,
           "text": "You&#39;ll need to use spin_lock() and spin_unlock() for shared data."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 92,
       "duplicates": [
        {
          "start_index": 210463,
           "end_index": 210682,
           "text": "Different Softirqs You&#39;ll need to use spin_lock() and spin_unlock() for shared data, whether it be a timer, tasklet, different softirq or the same or another softirq: any of them could be running on a different CPU."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 93,
       "duplicates": [
        {
          "start_index": 214909,
           "end_index": 215001,
           "text": "Common Examples Let&#39;s step through a simple example: a cache of number to name mappings."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 94,
       "duplicates": [
        {
          "start_index": 215343,
           "end_index": 218141,
           "text": "Here&#39;s the code: #include &amp;lt;linux/list.h&amp;gt; #include &amp;lt;linux/slab.h&amp;gt; #include &amp;lt;linux/string.h&amp;gt; #include &amp;lt;linux/mutex.h&amp;gt; #include &amp;lt;asm/errno.h&amp;gt; struct object { struct list_head list; int id; char name[32]; int popularity; }; /* Protects the cache, cache_num, and the objects within it */ static DEFINE_MUTEX(cache_lock); static LIST_HEAD(cache); static unsigned int cache_num = 0; #define MAX_CACHE_SIZE 10 /* Must be holding cache_lock */ static struct object *__cache_find(int id) { struct object *i; list_for_each_entry(i, &amp;amp;cache, list) if (i-&amp;gt;id == id) { i-&amp;gt;popularity++; return i; } return NULL; } /* Must be holding cache_lock */ static void __cache_delete(struct object *obj) { BUG_ON(!obj); list_del(&amp;amp;obj-&amp;gt;list); kfree(obj); cache_num--; } /* Must be holding cache_lock */ static void __cache_add(struct object *obj) { list_add(&amp;amp;obj-&amp;gt;list, &amp;amp;cache); if (++cache_num &amp;gt; MAX_CACHE_SIZE) { struct object *i, *outcast = NULL; list_for_each_entry(i, &amp;amp;cache, list) { if (!outcast || i-&amp;gt;popularity &amp;lt; outcast-&amp;gt;popularity) outcast = i; } __cache_delete(outcast); } } int cache_add(int id, const char *name) { struct object *obj; if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL) return -ENOMEM; strlcpy(obj-&amp;gt;name, name, sizeof(obj-&amp;gt;name)); obj-&amp;gt;id = id; obj-&amp;gt;popularity = 0; mutex_lock(&amp;amp;cache_lock); __cache_add(obj); mutex_unlock(&amp;amp;cache_lock); return 0; } void cache_delete(int id) { mutex_lock(&amp;amp;cache_lock); __cache_delete(__cache_find(id)); mutex_unlock(&amp;amp;cache_lock); } int cache_find(int id, char *name) { struct object *obj; int ret = -ENOENT; mutex_lock(&amp;amp;cache_lock); obj = __cache_find(id); if (obj) { ret = 0; strcpy(name, obj-&amp;gt;name); } mutex_unlock(&amp;amp;cache_lock); return ret; } Note that we always make sure we have the cache_lock when we add, delete, or look up the cache: both the cache infrastructure itself and the contents of the objects are protected by the lock. In this case it&#39;s easy, since we copy the data for the user, and never let them access the objects directly. There is a slight (and common) optimization here: in cache_add we set up the fields of the object before grabbing the lock. This is safe, as no-one else can access it until we put it in cache. Accessing From Interrupt Context Now consider the case where cache_find can be called from interrupt context: either a hardware interrupt or a softirq. An example would be a timer which deletes object from the cache. The change is shown below, in standard patch format: the - are lines which are taken away, and the + are lines which are added."
        },
         {
          "start_index": 218143,
           "end_index": 220580,
           "text": "--- cache.c.usercontext 2003-12-09 13:58:54.000000000 +1100 +++ cache.c.interrupt 2003-12-09 14:07:49.000000000 +1100 @@ -12,7 +12,7 @@ int popularity; }; -static DEFINE_MUTEX(cache_lock); +static DEFINE_SPINLOCK(cache_lock); static LIST_HEAD(cache); static unsigned int cache_num = 0; #define MAX_CACHE_SIZE 10 @@ -55,6 +55,7 @@ int cache_add(int id, const char *name) { struct object *obj; + unsigned long flags; if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL) return -ENOMEM; @@ -63,30 +64,33 @@ obj-&amp;gt;id = id; obj-&amp;gt;popularity = 0; - mutex_lock(&amp;amp;cache_lock); + spin_lock_irqsave(&amp;amp;cache_lock, flags); __cache_add(obj); - mutex_unlock(&amp;amp;cache_lock); + spin_unlock_irqrestore(&amp;amp;cache_lock, flags); return 0; } void cache_delete(int id) { - mutex_lock(&amp;amp;cache_lock); + unsigned long flags; + + spin_lock_irqsave(&amp;amp;cache_lock, flags); __cache_delete(__cache_find(id)); - mutex_unlock(&amp;amp;cache_lock); + spin_unlock_irqrestore(&amp;amp;cache_lock, flags); } int cache_find(int id, char *name) { struct object *obj; int ret = -ENOENT; + unsigned long flags; - mutex_lock(&amp;amp;cache_lock); + spin_lock_irqsave(&amp;amp;cache_lock, flags); obj = __cache_find(id); if (obj) { ret = 0; strcpy(name, obj-&amp;gt;name); } - mutex_unlock(&amp;amp;cache_lock); + spin_unlock_irqrestore(&amp;amp;cache_lock, flags); return ret; } Note that the spin_lock_irqsave will turn off interrupts if they are on, otherwise does nothing (if we are already in an interrupt handler), hence these functions are safe to call from any context. Unfortunately, cache_add calls kmalloc with the GFP_KERNEL flag, which is only legal in user context. I have assumed that cache_add is still only called in user context, otherwise this should become a parameter to cache_add. Exposing Objects Outside This File If our objects contained more information, it might not be sufficient to copy the information in and out: other parts of the code might want to keep pointers to these objects, for example, rather than looking up the id every time. This produces two problems. The first problem is that we use the cache_lock to protect objects: we&#39;d need to make this non-static so the rest of the code can use it. This makes locking trickier, as it is no longer all in one place."
        },
         {
          "start_index": 221279,
           "end_index": 224074,
           "text": "Here is the code: --- cache.c.interrupt 2003-12-09 14:25:43.000000000 +1100 +++ cache.c.refcnt 2003-12-09 14:33:05.000000000 +1100 @@ -7,6 +7,7 @@ struct object { struct list_head list; + unsigned int refcnt; int id; char name[32]; int popularity; @@ -17,6 +18,35 @@ static unsigned int cache_num = 0; #define MAX_CACHE_SIZE 10 +static void __object_put(struct object *obj) +{ + if (--obj-&amp;gt;refcnt == 0) + kfree(obj); +} + +static void __object_get(struct object *obj) +{ + obj-&amp;gt;refcnt++; +} + +void object_put(struct object *obj) +{ + unsigned long flags; + + spin_lock_irqsave(&amp;amp;cache_lock, flags); + __object_put(obj); + spin_unlock_irqrestore(&amp;amp;cache_lock, flags); +} + +void object_get(struct object *obj) +{ + unsigned long flags; + + spin_lock_irqsave(&amp;amp;cache_lock, flags); + __object_get(obj); + spin_unlock_irqrestore(&amp;amp;cache_lock, flags); +} + /* Must be holding cache_lock */ static struct object *__cache_find(int id) { @@ -35,6 +65,7 @@ { BUG_ON(!obj); list_del(&amp;amp;obj-&amp;gt;list); + __object_put(obj); cache_num--; } @@ -63,6 +94,7 @@ strlcpy(obj-&amp;gt;name, name, sizeof(obj-&amp;gt;name)); obj-&amp;gt;id = id; obj-&amp;gt;popularity = 0; + obj-&amp;gt;refcnt = 1; /* The cache holds a reference */ spin_lock_irqsave(&amp;amp;cache_lock, flags); __cache_add(obj); @@ -79,18 +111,15 @@ spin_unlock_irqrestore(&amp;amp;cache_lock, flags); } -int cache_find(int id, char *name) +struct object *cache_find(int id) { struct object *obj; - int ret = -ENOENT; unsigned long flags; spin_lock_irqsave(&amp;amp;cache_lock, flags); obj = __cache_find(id); - if (obj) { - ret = 0; - strcpy(name, obj-&amp;gt;name); - } + if (obj) + __object_get(obj); spin_unlock_irqrestore(&amp;amp;cache_lock, flags); - return ret; + return obj; } We encapsulate the reference counting in the standard &#39;get&#39; and &#39;put&#39; functions. Now we can return the object itself from cache_find which has the advantage that the user can now sleep holding the object (eg. to copy_to_user to name to userspace). The other point to note is that I said a reference should be held for every pointer to the object: thus the reference count is 1 when first inserted into the cache. In some versions the framework does not hold a reference count, but they are more complicated. Using Atomic Operations For The Reference Count In practice, atomic_t would usually be used for refcnt. There are a number of atomic operations defined in include/asm/atomic.h: these are guaranteed to be seen atomically from all CPUs in the system, so no lock is required."
        },
         {
          "start_index": 224367,
           "end_index": 227112,
           "text": "--- cache.c.refcnt 2003-12-09 15:00:35.000000000 +1100 +++ cache.c.refcnt-atomic 2003-12-11 15:49:42.000000000 +1100 @@ -7,7 +7,7 @@ struct object { struct list_head list; - unsigned int refcnt; + atomic_t refcnt; int id; char name[32]; int popularity; @@ -18,33 +18,15 @@ static unsigned int cache_num = 0; #define MAX_CACHE_SIZE 10 -static void __object_put(struct object *obj) -{ - if (--obj-&amp;gt;refcnt == 0) - kfree(obj); -} - -static void __object_get(struct object *obj) -{ - obj-&amp;gt;refcnt++; -} - void object_put(struct object *obj) { - unsigned long flags; - - spin_lock_irqsave(&amp;amp;cache_lock, flags); - __object_put(obj); - spin_unlock_irqrestore(&amp;amp;cache_lock, flags); + if (atomic_dec_and_test(&amp;amp;obj-&amp;gt;refcnt)) + kfree(obj); } void object_get(struct object *obj) { - unsigned long flags; - - spin_lock_irqsave(&amp;amp;cache_lock, flags); - __object_get(obj); - spin_unlock_irqrestore(&amp;amp;cache_lock, flags); + atomic_inc(&amp;amp;obj-&amp;gt;refcnt); } /* Must be holding cache_lock */ @@ -65,7 +47,7 @@ { BUG_ON(!obj); list_del(&amp;amp;obj-&amp;gt;list); - __object_put(obj); + object_put(obj); cache_num--; } @@ -94,7 +76,7 @@ strlcpy(obj-&amp;gt;name, name, sizeof(obj-&amp;gt;name)); obj-&amp;gt;id = id; obj-&amp;gt;popularity = 0; - obj-&amp;gt;refcnt = 1; /* The cache holds a reference */ + atomic_set(&amp;amp;obj-&amp;gt;refcnt, 1); /* The cache holds a reference */ spin_lock_irqsave(&amp;amp;cache_lock, flags); __cache_add(obj); @@ -119,7 +101,7 @@ spin_lock_irqsave(&amp;amp;cache_lock, flags); obj = __cache_find(id); if (obj) - __object_get(obj); + object_get(obj); spin_unlock_irqrestore(&amp;amp;cache_lock, flags); return obj; } Protecting The Objects Themselves In these examples, we assumed that the objects (except the reference counts) never changed once they are created. If we wanted to allow the name to change, there are three possibilities: You can make cache_lock non-static, and tell people to grab that lock before changing the name in any object. You can provide a cache_obj_rename which grabs this lock and changes the name for the caller, and tell everyone to use that function. You can make the cache_lock protect only the cache itself, and use another lock to protect the name. Theoretically, you can make the locks as fine-grained as one lock for every field, for every object. In practice, the most common variants are: One lock which protects the infrastructure (the cache list in this example) and all the objects. This is what we have done so far."
        },
         {
          "start_index": 240588,
           "end_index": 242852,
           "text": "*/ +static void cache_delete_rcu(void *arg) +{ + object_put(arg); +} + /* Must be holding cache_lock */ static void __cache_delete(struct object *obj) { BUG_ON(!obj); - list_del(&amp;amp;obj-&amp;gt;list); - object_put(obj); + list_del_rcu(&amp;amp;obj-&amp;gt;list); cache_num--; + call_rcu(&amp;amp;obj-&amp;gt;rcu, cache_delete_rcu); } /* Must be holding cache_lock */ static void __cache_add(struct object *obj) { - list_add(&amp;amp;obj-&amp;gt;list, &amp;amp;cache); + list_add_rcu(&amp;amp;obj-&amp;gt;list, &amp;amp;cache); if (++cache_num &amp;gt; MAX_CACHE_SIZE) { struct object *i, *outcast = NULL; list_for_each_entry(i, &amp;amp;cache, list) { @@ -104,12 +114,11 @@ struct object *cache_find(int id) { struct object *obj; - unsigned long flags; - spin_lock_irqsave(&amp;amp;cache_lock, flags); + rcu_read_lock(); obj = __cache_find(id); if (obj) object_get(obj); - spin_unlock_irqrestore(&amp;amp;cache_lock, flags); + rcu_read_unlock(); return obj; } Note that the reader will alter the popularity member in __cache_find(), and now it doesn&#39;t hold a lock. One solution would be to make it an atomic_t, but for this usage, we don&#39;t really care about races: an approximate result is good enough, so I didn&#39;t change it. The result is that cache_find() requires no synchronization with any other functions, so is almost as fast on SMP as it would be on UP. There is a furthur optimization possible here: remember our original cache code, where there were no reference counts and the caller simply held the lock whenever using the object? This is still possible: if you hold the lock, no one can delete the object, so you don&#39;t need to get and put the reference count. Now, because the &#39;read lock&#39; in RCU is simply disabling preemption, a caller which always has preemption disabled between calling cache_find() and object_put() does not need to actually get and put the reference count: we could expose __cache_find() by making it non-static, and such callers could simply call that. The benefit here is that the reference count is not written to: the object is not altered in any way, which is much faster on SMP machines due to caching."
        }
      ]
    },
     {
      "group_id": 95,
       "duplicates": [
        {
          "start_index": 227784,
           "end_index": 228412,
           "text": "*/ int id; + + spinlock_t lock; /* Protects the name */ char name[32]; - int popularity; }; static DEFINE_SPINLOCK(cache_lock); @@ -77,6 +84,7 @@ obj-&amp;gt;id = id; obj-&amp;gt;popularity = 0; atomic_set(&amp;amp;obj-&amp;gt;refcnt, 1); /* The cache holds a reference */ + spin_lock_init(&amp;amp;obj-&amp;gt;lock); spin_lock_irqsave(&amp;amp;cache_lock, flags); __cache_add(obj); Note that I decide that the popularity count should be protected by the cache_lock rather than the per-object lock: this is because it (like the struct list_head inside the object) is logically part of the infrastructure."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 96,
       "duplicates": [
        {
          "start_index": 228414,
           "end_index": 228520,
           "text": "This way, I don&#39;t need to grab the lock of every object in __cache_add when seeking the least popular."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 97,
       "duplicates": [
        {
          "start_index": 228522,
           "end_index": 228738,
           "text": "I also decided that the id member is unchangeable, so I don&#39;t need to grab each object lock in __cache_find() to examine the id: the object lock is only used by a caller who wants to read or write the name field."
        },
         {
          "start_index": 497186,
           "end_index": 497223,
           "text": "You can read them but not write them."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 98,
       "duplicates": [
        {
          "start_index": 229825,
           "end_index": 229885,
           "text": "You&#39;ll still get data corruption in the second example)."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 99,
       "duplicates": [
        {
          "start_index": 230684,
           "end_index": 231015,
           "text": "Secondly, if the same softirq on another CPU is trying to move another object in the reverse direction, the following could happen: ConsequencesCPU 1CPU 2Grab lock A -&amp;gt; OKGrab lock B -&amp;gt; OKGrab lock B -&amp;gt; spinGrab lock A -&amp;gt; spin The two CPUs will spin forever, waiting for the other to give up their lock."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 100,
       "duplicates": [
        {
          "start_index": 232265,
           "end_index": 232330,
           "text": "If you don&#39;t see why, please stay the fuck away from my code."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 101,
       "duplicates": [
        {
          "start_index": 232531,
           "end_index": 233243,
           "text": "If you want to destroy the entire collection (say on module removal), you might do the following: /* THIS CODE BAD BAD BAD BAD: IF IT WAS ANY WORSE IT WOULD USE HUNGARIAN NOTATION */ spin_lock_bh(&amp;amp;list_lock); while (list) { struct foo *next = list-&amp;gt;next; del_timer(&amp;amp;list-&amp;gt;timer); kfree(list); list = next; } spin_unlock_bh(&amp;amp;list_lock); Sooner or later, this will crash on SMP, because a timer can have just gone off before the spin_lock_bh(), and it will only get the lock after we spin_unlock_bh(), and then try to free the element (which has already been freed!). This can be avoided by checking the result of del_timer(): if it returns 1, the timer has been deleted."
        },
         {
          "start_index": 233244,
           "end_index": 233885,
           "text": "If 0, it means (in this case) that it is currently running, so we can do: retry: spin_lock_bh(&amp;amp;list_lock); while (list) { struct foo *next = list-&amp;gt;next; if (!del_timer(&amp;amp;list-&amp;gt;timer)) { /* Give timer a chance to delete this */ spin_unlock_bh(&amp;amp;list_lock); goto retry; } kfree(list); list = next; } spin_unlock_bh(&amp;amp;list_lock); Another common problem is deleting timers which restart themselves (by calling add_timer() at the end of their timer function). Because this is a fairly common case which is prone to races, you should use del_timer_sync() (include/linux/timer.h) to handle this case."
        }
      ]
    },
     {
      "group_id": 102,
       "duplicates": [
        {
          "start_index": 236940,
           "end_index": 237109,
           "text": "For example, adding new to a single linked list called list: new-&amp;gt;next = list-&amp;gt;next; wmb(); list-&amp;gt;next = new; The wmb() is a write memory barrier."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 103,
       "duplicates": [
        {
          "start_index": 237864,
           "end_index": 238035,
           "text": "list-&amp;gt;next = old-&amp;gt;next; There is list_del_rcu() (include/linux/list.h) which does this (the normal version poisons the old object, which we don&#39;t want)."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 104,
       "duplicates": [
        {
          "start_index": 239663,
           "end_index": 240587,
           "text": "--- cache.c.perobjectlock 2003-12-11 17:15:03.000000000 +1100 +++ cache.c.rcupdate 2003-12-11 17:55:14.000000000 +1100 @@ -1,15 +1,18 @@ #include &amp;lt;linux/list.h&amp;gt; #include &amp;lt;linux/slab.h&amp;gt; #include &amp;lt;linux/string.h&amp;gt; +#include &amp;lt;linux/rcupdate.h&amp;gt; #include &amp;lt;linux/mutex.h&amp;gt; #include &amp;lt;asm/errno.h&amp;gt; struct object { - /* These two protected by cache_lock. */ + /* This is protected by RCU */ struct list_head list; int popularity; + struct rcu_head rcu; + atomic_t refcnt; /* Doesn&#39;t change once created. */ @@ -40,7 +43,7 @@ { struct object *i; - list_for_each_entry(i, &amp;amp;cache, list) { + list_for_each_entry_rcu(i, &amp;amp;cache, list) { if (i-&amp;gt;id == id) { i-&amp;gt;popularity++; return i; @@ -49,19 +52,25 @@ return NULL; } +/* Final discard done once we know no readers are looking."
        },
         {
          "start_index": 458823,
           "end_index": 459352,
           "text": "#include &amp;lt;linux/init.h&amp;gt; #include &amp;lt;linux/pci.h&amp;gt; #include &amp;lt;linux/slab.h&amp;gt; #include &amp;lt;sound/core.h&amp;gt; #include &amp;lt;sound/initval.h&amp;gt; where the last one is necessary only when module options are defined in the source file. If the code is split into several files, the files without module options don&#39;t need them. In addition to these headers, you&#39;ll need &amp;lt;linux/interrupt.h&amp;gt; for interrupt handling, and &amp;lt;asm/io.h&amp;gt; for I/O access."
        }
      ]
    },
     {
      "group_id": 105,
       "duplicates": [
        {
          "start_index": 255934,
           "end_index": 256097,
           "text": "kgdboc argumentsUsage: kgdboc=[kms][[,]kbd][[,]serial_device][,baud]The order listed above must be observed if you use any of the optional configurations together."
        },
         {
          "start_index": 256305,
           "end_index": 256400,
           "text": "The order listed above must be observed if you use any of the optional configurations together."
        }
      ]
    },
     {
      "group_id": 106,
       "duplicates": [
        {
          "start_index": 256402,
           "end_index": 256750,
           "text": "Using kms + only gdb is generally not a useful combination.Using loadable module or built-inAs a kernel built-in:Use the kernel boot argument: kgdboc=&amp;lt;tty-device&amp;gt;,[baud]As a kernel loadable module:Use the command: modprobe kgdboc kgdboc=&amp;lt;tty-device&amp;gt;,[baud]Here are two examples of how you might format the kgdboc string."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 107,
       "duplicates": [
        {
          "start_index": 257053,
           "end_index": 257663,
           "text": "Here are two examples:Enable kgdboc on ttyS0echo ttyS0 &amp;gt; /sys/module/kgdboc/parameters/kgdbocDisable kgdbocecho &quot;&quot; &amp;gt; /sys/module/kgdboc/parameters/kgdbocNOTE: You do not need to specify the baud if you are configuring the console on tty which is already configured or open.More examplesYou can configure kgdboc to use the keyboard, and or a serial device depending on if you are using kdb and or kgdb, in one of the following scenarios.You can configure kgdboc to use the keyboard, and or a serial device depending on if you are using kdb and or kgdb, in one of the following scenarios."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 108,
       "duplicates": [
        {
          "start_index": 257664,
           "end_index": 258131,
           "text": "kdb and kgdb over only a serial portkgdboc=&amp;lt;serial_device&amp;gt;[,baud]Example: kgdboc=ttyS0,115200kdb and kgdb with keyboard and a serial portkgdboc=kbd,&amp;lt;serial_device&amp;gt;[,baud]Example: kgdboc=kbd,ttyS0,115200kdb with a keyboardkgdboc=kbdkdb with kernel mode settingkgdboc=kms,kbdkdb with kernel mode setting and kgdb over a serial portkgdboc=kms,kbd,ttyS0,115200 NOTE: Kgdboc does not support interrupting the target via the gdb remote protocol."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 109,
       "duplicates": [
        {
          "start_index": 260208,
           "end_index": 260499,
           "text": "Activate with the kernel command line option:kgdbconUse sysfs before configuring an I/O driverecho 1 &amp;gt; /sys/module/kgdb/parameters/kgdb_use_con NOTE: If you do this after you configure the kgdb I/O driver, the setting will not take effect until the next point the I/O is reconfigured."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 110,
       "duplicates": [
        {
          "start_index": 260919,
           "end_index": 261645,
           "text": "The default behavior is always set to 0.echo -1 &amp;gt; /sys/module/debug_core/parameters/kgdbrebootIgnore the reboot notification entirely.echo 0 &amp;gt; /sys/module/debug_core/parameters/kgdbrebootSend the detach message to any attached debugger client.echo 1 &amp;gt; /sys/module/debug_core/parameters/kgdbrebootEnter the debugger on reboot notify.Using kdb Quick start for kdb on a serial portThis is a quick example of how to use kdb.Boot kernel with arguments: console=ttyS0,115200 kgdboc=ttyS0,115200ORConfigure kgdboc after the kernel booted; assuming you are using a serial port console: echo ttyS0 &amp;gt; /sys/module/kgdboc/parameters/kgdboc Enter the kernel debugger manually or by waiting for an oops or fault."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 111,
       "duplicates": [
        {
          "start_index": 261647,
           "end_index": 262708,
           "text": "There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g, which means you must have enabled CONFIG_MAGIC_SYSRQ=y in your kernel config.When logged in as root or with a super user session you can run:echo g &amp;gt; /proc/sysrq-triggerExample using minicom 2.2Press: Control-aPress: fPress: gWhen you have telneted to a terminal server that supports sending a remote breakPress: Control-]Type in:send breakPress: EnterPress: gFrom the kdb prompt you can run the &quot;help&quot; command to see a complete list of the commands that are available.Some useful commands in kdb include: lsmod -- Shows where kernel modules are loadedps -- Displays only the active processesps A -- Shows all the processessummary -- Shows kernel version info and memory usagebt -- Get a backtrace of the current process using dump_stack()dmesg -- View the kernel syslog buffergo -- Continue the system When you are done using kdb you need to consider rebooting the system or using the &quot;go&quot; command to resuming normal kernel execution."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 112,
       "duplicates": [
        {
          "start_index": 262710,
           "end_index": 263280,
           "text": "If you have paused the kernel for a lengthy period of time, applications that rely on timely networking or anything to do with real wall clock time could be adversely affected, so you should take this into consideration when using the kernel debugger.Quick start for kdb using a keyboard connected consoleThis is a quick example of how to use kdb with a keyboard.Boot kernel with arguments: kgdboc=kbdORConfigure kgdboc after the kernel booted: echo kbd &amp;gt; /sys/module/kgdboc/parameters/kgdboc Enter the kernel debugger manually or by waiting for an oops or fault."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 113,
       "duplicates": [
        {
          "start_index": 263282,
           "end_index": 264123,
           "text": "There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g, which means you must have enabled CONFIG_MAGIC_SYSRQ=y in your kernel config.When logged in as root or with a super user session you can run:echo g &amp;gt; /proc/sysrq-triggerExample using a laptop keyboardPress and hold down: AltPress and hold down: FnPress and release the key with the label: SysRqRelease: FnPress and release: gRelease: AltExample using a PS/2 101-key keyboardPress and hold down: AltPress and release the key with the label: SysRqPress and release: gRelease: AltNow type in a kdb command such as &quot;help&quot;, &quot;dmesg&quot;, &quot;bt&quot; or &quot;go&quot; to continue kernel execution.Using kgdb / gdbIn order to use kgdb you must activate it by passing configuration information to one of the kgdb I/O drivers."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 114,
       "duplicates": [
        {
          "start_index": 264401,
           "end_index": 264610,
           "text": "All kgdb I/O drivers can be reconfigured at run time, if CONFIG_SYSFS and CONFIG_MODULES are enabled, by echo&#39;ing a new config string to /sys/module/&amp;lt;driver&amp;gt;/parameter/&amp;lt;option&amp;gt;."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 115,
       "duplicates": [
        {
          "start_index": 264847,
           "end_index": 265165,
           "text": "Connecting with gdb to a serial portConfigure kgdbocBoot kernel with arguments: kgdboc=ttyS0,115200ORConfigure kgdboc after the kernel booted: echo ttyS0 &amp;gt; /sys/module/kgdboc/parameters/kgdbocStop kernel execution (break into the debugger)In order to connect to gdb via kgdboc, the kernel must first be stopped."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 116,
       "duplicates": [
        {
          "start_index": 265366,
           "end_index": 265994,
           "text": "When logged in as root or with a super user session you can run:echo g &amp;gt; /proc/sysrq-triggerExample using minicom 2.2Press: Control-aPress: fPress: gWhen you have telneted to a terminal server that supports sending a remote breakPress: Control-]Type in:send breakPress: EnterPress: g Connect from from gdb Example (using a directly connected port): % gdb ./vmlinux (gdb) set remotebaud 115200 (gdb) target remote /dev/ttyS0 Example (kgdb to a terminal server on TCP port 2012): % gdb ./vmlinux (gdb) target remote 192.168.2.2:2012 Once connected, you can debug a kernel the way you would debug an application program."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 117,
       "duplicates": [
        {
          "start_index": 268115,
           "end_index": 268250,
           "text": "You don&#39;t want to execute any of the run control or breakpoint operations, because it can disrupt the state of the kernel debugger."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 118,
       "duplicates": [
        {
          "start_index": 268465,
           "end_index": 268662,
           "text": "To see all the kdb commands you can run monitor help.Example: (gdb) monitor ps 1 idle process (state I) and 27 sleeping system daemon (state M) processes suppressed, use &#39;ps A&#39; to see all."
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 119,
       "duplicates": [
        {
          "start_index": 273736,
           "end_index": 273839,
           "text": "There are a few flags which must be set on every architecture in their &amp;lt;asm/kgdb.h&amp;gt; file."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 120,
       "duplicates": [
        {
          "start_index": 279228,
           "end_index": 279403,
           "text": "libATA provides an ATA driver API, class transports for ATA and ATAPI devices, and SCSI&amp;lt;-&amp;gt;ATA translation for ATA devices according to the T10 SAT specification."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 121,
       "duplicates": [
        {
          "start_index": 279713,
           "end_index": 279822,
           "text": "FIS-based drivers will hook into the system with -&amp;gt;qc_prep() and -&amp;gt;qc_issue() high-level hooks."
        },
         {
          "start_index": 287041,
           "end_index": 287101,
           "text": "More advanced drivers implement their own -&amp;gt;qc_issue."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 122,
       "duplicates": [
        {
          "start_index": 281109,
           "end_index": 281211,
           "text": "The optional -&amp;gt;mode_filter() hook is called when libata has built a mask of the possible modes."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 123,
       "duplicates": [
        {
          "start_index": 281212,
           "end_index": 281364,
           "text": "This is passed to the -&amp;gt;mode_filter() function which should return a mask of valid modes after filtering those unsuitable due to hardware limits."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 124,
       "duplicates": [
        {
          "start_index": 281418,
           "end_index": 281561,
           "text": "dev-&amp;gt;pio_mode and dev-&amp;gt;dma_mode are guaranteed to be valid when -&amp;gt;set_piomode() and when -&amp;gt;set_dmamode() is called."
        },
         {
          "start_index": 281889,
           "end_index": 282005,
           "text": "-&amp;gt;set_piomode() is always called (if present), but -&amp;gt;set_dma_mode() is only called if DMA is possible."
        },
         {
          "start_index": 287103,
           "end_index": 287236,
           "text": "ata_qc_issue_prot() calls -&amp;gt;tf_load(), -&amp;gt;bmdma_setup(), and -&amp;gt;bmdma_start() as necessary to initiate a transfer."
        },
         {
          "start_index": 290863,
           "end_index": 290921,
           "text": "-&amp;gt;port_stop() is called after -&amp;gt;host_stop()."
        },
         {
          "start_index": 291095,
           "end_index": 291178,
           "text": "-&amp;gt;host_stop() is called after all -&amp;gt;port_stop() calls have completed."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 125,
       "duplicates": [
        {
          "start_index": 290863,
           "end_index": 291025,
           "text": "-&amp;gt;port_stop() is called after -&amp;gt;host_stop(). Its sole function is to release DMA/memory resources, now that they are no longer actively being used."
        },
         {
          "start_index": 291095,
           "end_index": 291259,
           "text": "-&amp;gt;host_stop() is called after all -&amp;gt;port_stop() calls have completed. The hook must finalize hardware shutdown, release DMA and other resources, etc."
        }
      ]
    },
     {
      "group_id": 126,
       "duplicates": [
        {
          "start_index": 282006,
           "end_index": 282257,
           "text": "Taskfile read/write void (*sff_tf_load) (struct ata_port *ap, struct ata_taskfile *tf); void (*sff_tf_read) (struct ata_port *ap, struct ata_taskfile *tf); -&amp;gt;tf_load() is called to load the given taskfile into hardware registers / DMA buffers."
        },
         {
          "start_index": 290863,
           "end_index": 290921,
           "text": "-&amp;gt;port_stop() is called after -&amp;gt;host_stop()."
        },
         {
          "start_index": 291095,
           "end_index": 291178,
           "text": "-&amp;gt;host_stop() is called after all -&amp;gt;port_stop() calls have completed."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 127,
       "duplicates": [
        {
          "start_index": 282259,
           "end_index": 282388,
           "text": "-&amp;gt;tf_read() is called to read the hardware registers / DMA buffers, to obtain the current set of taskfile register values."
        },
         {
          "start_index": 290863,
           "end_index": 290921,
           "text": "-&amp;gt;port_stop() is called after -&amp;gt;host_stop()."
        },
         {
          "start_index": 291095,
           "end_index": 291178,
           "text": "-&amp;gt;host_stop() is called after all -&amp;gt;port_stop() calls have completed."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 128,
       "duplicates": [
        {
          "start_index": 282868,
           "end_index": 283055,
           "text": "ATA command execute void (*sff_exec_command)(struct ata_port *ap, struct ata_taskfile *tf); causes an ATA command, previously loaded with -&amp;gt;tf_load(), to be initiated in hardware."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 129,
       "duplicates": [
        {
          "start_index": 283056,
           "end_index": 283138,
           "text": "Most drivers for taskfile-based hardware use ata_sff_exec_command() for this hook."
        },
         {
          "start_index": 283784,
           "end_index": 283866,
           "text": "Most drivers for taskfile-based hardware use ata_sff_check_status() for this hook."
        },
         {
          "start_index": 284370,
           "end_index": 284450,
           "text": "Most drivers for taskfile-based hardware use ata_sff_dev_select() for this hook."
        }
      ]
    },
     {
      "group_id": 130,
       "duplicates": [
        {
          "start_index": 283383,
           "end_index": 283484,
           "text": "This hook may be specified as NULL, in which case libata will assume that atapi dma can be supported."
        },
         {
          "start_index": 291260,
           "end_index": 291327,
           "text": "This hook may be specified as NULL, in which case it is not called."
        }
      ]
    },
     {
      "group_id": 131,
       "duplicates": [
        {
          "start_index": 285154,
           "end_index": 285540,
           "text": "Control PCI IDE BMDMA engine void (*bmdma_setup) (struct ata_queued_cmd *qc); void (*bmdma_start) (struct ata_queued_cmd *qc); void (*bmdma_stop) (struct ata_port *ap); u8 (*bmdma_status) (struct ata_port *ap); When setting up an IDE BMDMA transaction, these hooks arm (-&amp;gt;bmdma_setup), fire (-&amp;gt;bmdma_start), and halt (-&amp;gt;bmdma_stop) the hardware&#39;s DMA engine."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 132,
       "duplicates": [
        {
          "start_index": 285542,
           "end_index": 285621,
           "text": "-&amp;gt;bmdma_status is used to read the standard PCI IDE DMA Status register."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 133,
       "duplicates": [
        {
          "start_index": 286584,
           "end_index": 286729,
           "text": "-&amp;gt;qc_prep is called after the buffers have been DMA-mapped, and is typically used to populate the hardware&#39;s DMA scatter-gather table."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 134,
       "duplicates": [
        {
          "start_index": 286834,
           "end_index": 286938,
           "text": "-&amp;gt;qc_issue is used to make a command active, once the hardware and S/G tables have been prepared."
        },
         {
          "start_index": 287041,
           "end_index": 287101,
           "text": "More advanced drivers implement their own -&amp;gt;qc_issue."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 135,
       "duplicates": [
        {
          "start_index": 287369,
           "end_index": 287406,
           "text": "Use -&amp;gt;error_handler() instead."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 136,
       "duplicates": [
        {
          "start_index": 287718,
           "end_index": 287811,
           "text": "The optional -&amp;gt;freeze() callback can be used for freezing the port hardware-wise (e.g."
        },
         {
          "start_index": 287987,
           "end_index": 288130,
           "text": "The optional -&amp;gt;thaw() callback is called to perform the opposite of -&amp;gt;freeze(): prepare the port for normal operation once again."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 137,
       "duplicates": [
        {
          "start_index": 288175,
           "end_index": 288336,
           "text": "void (*error_handler) (struct ata_port *ap); -&amp;gt;error_handler() is a driver&#39;s hook into probe, hotplug, and recovery and other exceptional conditions."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 138,
       "duplicates": [
        {
          "start_index": 288338,
           "end_index": 288574,
           "text": "The primary responsibility of an implementation is to call ata_do_eh() or ata_bmdma_drive_eh() with a set of EH hooks as arguments: &#39;prereset&#39; hook (may be NULL) is called during an EH reset, before any other actions are taken."
        },
         {
          "start_index": 288576,
           "end_index": 288657,
           "text": "&#39;postreset&#39; hook (may be NULL) is called after the EH reset is performed."
        }
      ]
    },
     {
      "group_id": 139,
       "duplicates": [
        {
          "start_index": 289069,
           "end_index": 289289,
           "text": "Hardware interrupt handling irqreturn_t (*irq_handler)(int, void *, struct pt_regs *); void (*irq_clear) (struct ata_port *); -&amp;gt;irq_handler is the interrupt handling routine registered with the system, by libata."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 140,
       "duplicates": [
        {
          "start_index": 289291,
           "end_index": 289411,
           "text": "-&amp;gt;irq_clear is called during probe just before the interrupt handler is registered, to be sure hardware is quiet."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 141,
       "duplicates": [
        {
          "start_index": 290062,
           "end_index": 290153,
           "text": "Currently only used if -&amp;gt;phy_reset hook called the sata_phy_reset() helper function."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 142,
       "duplicates": [
        {
          "start_index": 290222,
           "end_index": 290467,
           "text": "Init and shutdown int (*port_start) (struct ata_port *ap); void (*port_stop) (struct ata_port *ap); void (*host_stop) (struct ata_host_set *host_set); -&amp;gt;port_start() is called just after the data structures for each port are initialized."
        },
         {
          "start_index": 290863,
           "end_index": 290921,
           "text": "-&amp;gt;port_stop() is called after -&amp;gt;host_stop()."
        },
         {
          "start_index": 291095,
           "end_index": 291178,
           "text": "-&amp;gt;host_stop() is called after all -&amp;gt;port_stop() calls have completed."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 143,
       "duplicates": [
        {
          "start_index": 290580,
           "end_index": 290693,
           "text": "Some drivers also use this entry point as a chance to allocate driver-private memory for ap-&amp;gt;private_data."
        },
         {
          "start_index": 295851,
           "end_index": 295905,
           "text": "ap-&amp;gt;active_tag and qc-&amp;gt;tag are poisoned."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 144,
       "duplicates": [
        {
          "start_index": 292630,
           "end_index": 292931,
           "text": "One is via qc-&amp;gt;complete_fn() callback and the other is completion qc-&amp;gt;waiting. qc-&amp;gt;complete_fn() callback is the asynchronous path used by normal SCSI translated commands and qc-&amp;gt;waiting is the synchronous (issuer sleeps in process context) path used by internal commands."
        },
         {
          "start_index": 295611,
           "end_index": 295706,
           "text": "qc-&amp;gt;complete_fn() callback is invoked. If the return value of the callback is not zero."
        }
      ]
    },
     {
      "group_id": 145,
       "duplicates": [
        {
          "start_index": 293014,
           "end_index": 293110,
           "text": "SCSI commands All libata drivers use ata_scsi_queuecmd() as hostt-&amp;gt;queuecommand callback."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 146,
       "duplicates": [
        {
          "start_index": 293381,
           "end_index": 293477,
           "text": "SCSI midlayer&#39;s completion notification function pointer is stored into qc-&amp;gt;scsidone."
        },
         {
          "start_index": 295559,
           "end_index": 295609,
           "text": "ATA_QCFLAG_ACTIVE is clared from qc-&amp;gt;flags."
        },
         {
          "start_index": 295851,
           "end_index": 295905,
           "text": "ap-&amp;gt;active_tag and qc-&amp;gt;tag are poisoned."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 147,
       "duplicates": [
        {
          "start_index": 293479,
           "end_index": 293549,
           "text": "qc-&amp;gt;complete_fn() callback is used for completion notification."
        },
         {
          "start_index": 295559,
           "end_index": 295609,
           "text": "ATA_QCFLAG_ACTIVE is clared from qc-&amp;gt;flags."
        },
         {
          "start_index": 295611,
           "end_index": 295656,
           "text": "qc-&amp;gt;complete_fn() callback is invoked."
        },
         {
          "start_index": 295851,
           "end_index": 295905,
           "text": "ap-&amp;gt;active_tag and qc-&amp;gt;tag are poisoned."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 148,
       "duplicates": [
        {
          "start_index": 293638,
           "end_index": 293734,
           "text": "Both functions end up calling qc-&amp;gt;scsidone to notify upper layer when the qc is finished."
        },
         {
          "start_index": 295559,
           "end_index": 295609,
           "text": "ATA_QCFLAG_ACTIVE is clared from qc-&amp;gt;flags."
        },
         {
          "start_index": 295770,
           "end_index": 295849,
           "text": "__ata_qc_complete() is called, which does qc-&amp;gt;flags is cleared to zero."
        },
         {
          "start_index": 295851,
           "end_index": 295905,
           "text": "ap-&amp;gt;active_tag and qc-&amp;gt;tag are poisoned."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 149,
       "duplicates": [
        {
          "start_index": 293807,
           "end_index": 293942,
           "text": "Note that SCSI midlayer invokes hostt-&amp;gt;queuecommand while holding host_set lock, so all above occur while holding host_set lock."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 150,
       "duplicates": [
        {
          "start_index": 295907,
           "end_index": 295973,
           "text": "qc-&amp;gt;waiting is claread &amp;amp; completed (in that order)."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 151,
       "duplicates": [
        {
          "start_index": 295975,
           "end_index": 296043,
           "text": "qc is deallocated by clearing appropriate bit in ap-&amp;gt;qactive."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 152,
       "duplicates": [
        {
          "start_index": 296509,
           "end_index": 296664,
           "text": "If an ATAPI command fails, ata_qc_complete() is invoked with error status, which in turn invokes atapi_qc_complete() via qc-&amp;gt;complete_fn() callback."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 153,
       "duplicates": [
        {
          "start_index": 296666,
           "end_index": 296781,
           "text": "This makes atapi_qc_complete() set scmd-&amp;gt;result to SAM_STAT_CHECK_CONDITION, complete the scmd and return 1."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 154,
       "duplicates": [
        {
          "start_index": 296783,
           "end_index": 296975,
           "text": "As the sense data is empty but scmd-&amp;gt;result is CHECK CONDITION, SCSI midlayer will invoke EH for the scmd, and returning 1 makes ata_qc_complete() to return without deallocating the qc."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 155,
       "duplicates": [
        {
          "start_index": 297039,
           "end_index": 297140,
           "text": "ata_scsi_error() ata_scsi_error() is the current transportt-&amp;gt;eh_strategy_handler() for libata."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 156,
       "duplicates": [
        {
          "start_index": 297772,
           "end_index": 297865,
           "text": "Here, we override qc-&amp;gt;scsidone with scsi_finish_command() and calls ata_qc_complete()."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 157,
       "duplicates": [
        {
          "start_index": 301482,
           "end_index": 301607,
           "text": "Examples ATA_STATUS doesn&#39;t contain !BSY &amp;amp;&amp;amp; DRDY &amp;amp;&amp;amp; !DRQ while trying to issue a command."
        },
         {
          "start_index": 301609,
           "end_index": 301663,
           "text": "!BSY &amp;amp;&amp;amp; !DRQ during PIO data transfer."
        },
         {
          "start_index": 301693,
           "end_index": 301794,
           "text": "!BSY &amp;amp;&amp;amp; ERR after CDB transfer starts but before the last byte of CDB is transferred."
        },
         {
          "start_index": 302888,
           "end_index": 303014,
           "text": "For ATA commands, this type of errors are indicated by !BSY &amp;amp;&amp;amp; ERR during command execution and on completion."
        },
         {
          "start_index": 303015,
           "end_index": 303188,
           "text": "For ATAPI commands, !BSY &amp;amp;&amp;amp; ERR &amp;amp;&amp;amp; ABRT right after issuing PACKET indicates that PACKET command is not supported and falls in this category."
        },
         {
          "start_index": 303190,
           "end_index": 303356,
           "text": "!BSY &amp;amp;&amp;amp; ERR(==CHK) &amp;amp;&amp;amp; !ABRT after the last byte of CDB is transferred indicates CHECK CONDITION and doesn&#39;t fall in this category."
        },
         {
          "start_index": 303358,
           "end_index": 303534,
           "text": "!BSY &amp;amp;&amp;amp; ERR(==CHK) &amp;amp;&amp;amp; ABRT after the last byte of CDB is transferred *probably* indicates CHECK CONDITION and doesn&#39;t fall in this category."
        }
      ]
    },
     {
      "group_id": 158,
       "duplicates": [
        {
          "start_index": 305152,
           "end_index": 305311,
           "text": "Media changed / media change requested error &amp;lt;&amp;lt;TODO: fill here&amp;gt;&amp;gt; Address error This is indicated by IDNF bit in the ERROR register."
        },
         {
          "start_index": 309980,
           "end_index": 310146,
           "text": "Hotplug and power management exceptions &amp;lt;&amp;lt;TODO: fill here&amp;gt;&amp;gt; EH recovery actions This section discusses several important recovery actions."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 159,
       "duplicates": [
        {
          "start_index": 309146,
           "end_index": 309280,
           "text": "This type of errors must be logged as it indicates something is very wrong with the system. Resetting host controller is recommended."
        },
         {
          "start_index": 309477,
           "end_index": 309555,
           "text": "This type of errors must be logged. Resetting host controller is recommended."
        }
      ]
    },
     {
      "group_id": 160,
       "duplicates": [
        {
          "start_index": 309980,
           "end_index": 310146,
           "text": "Hotplug and power management exceptions &amp;lt;&amp;lt;TODO: fill here&amp;gt;&amp;gt; EH recovery actions This section discusses several important recovery actions."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 161,
       "duplicates": [
        {
          "start_index": 315171,
           "end_index": 315448,
           "text": "Reed-Solomon Library Programming InterfaceThomasGleixnertglx@linutronix.de2004Thomas Gleixner This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 366216,
           "end_index": 366399,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 374186,
           "end_index": 374431,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 377842,
           "end_index": 378098,
           "text": "SCSI Interfaces GuideJamesBottomleyJames.Bottomley@hansenpartnership.comRobLandleyrob@landley.net2007Linux Foundation This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2."
        },
         {
          "start_index": 386014,
           "end_index": 386197,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 386707,
           "end_index": 387174,
           "text": "Memory ManagementSH-4Store Queue API SH-5TLB Interfaces Machine Specific Interfacesmach-dreamcast mach-x3proto BussesSuperHyway Maple The Linux Kernel Tracepoint APIJasonBaronjbaron@redhat.comWilliamCohenwcohen@redhat.com This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 415247,
           "end_index": 415540,
           "text": "Linutronix homepage.The Linux-USB Host Side API This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 445144,
           "end_index": 445428,
           "text": "Copyright (c) 2002-2005 Takashi Iwai tiwai@suse.de This document is free; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 572401,
           "end_index": 572731,
           "text": "Writing USB Device DriversGregKroah-Hartmangreg@kroah.com2001-2002Greg Kroah-Hartman This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        }
      ]
    },
     {
      "group_id": 162,
       "duplicates": [
        {
          "start_index": 317688,
           "end_index": 317944,
           "text": "The databytes are expanded to the given symbol size on the fly. There is no support for encoding continuous bitstreams with a symbol size != 8 at the moment. If it is necessary it should be not a big deal to implement such functionality. /* Parity buffer."
        },
         {
          "start_index": 318701,
           "end_index": 319016,
           "text": "The databytes are expanded to the given symbol size on the fly. There is no support for decoding continuous bitstreams with a symbolsize != 8 at the moment. If it is necessary it should be not a big deal to implement such functionality. Decoding with syndrome calculation, direct data correction /* Parity buffer."
        }
      ]
    },
     {
      "group_id": 163,
       "duplicates": [
        {
          "start_index": 319017,
           "end_index": 319342,
           "text": "Size = number of roots */ uint16_t par[6]; uint8_t data[512]; int numerr; /* Receive data */ ..... /* Receive parity */ ..... /* Decode 512 byte in data8. */ numerr = decode_rs8 (rs_decoder, data8, par, 512, NULL, 0, NULL, 0, NULL); Decoding with syndrome given by hardware decoder, direct data correction /* Parity buffer."
        },
         {
          "start_index": 319343,
           "end_index": 319707,
           "text": "Size = number of roots */ uint16_t par[6], syn[6]; uint8_t data[512]; int numerr; /* Receive data */ ..... /* Receive parity */ ..... /* Get syndrome from hardware decoder */ ..... /* Decode 512 byte in data8. */ numerr = decode_rs8 (rs_decoder, data8, par, 512, syn, 0, NULL, 0, NULL); Decoding with syndrome given by hardware decoder, no direct data correction."
        }
      ]
    },
     {
      "group_id": 164,
       "duplicates": [
        {
          "start_index": 319709,
           "end_index": 319786,
           "text": "Note: It&#39;s not necessary to give data and received parity to the decoder."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 165,
       "duplicates": [
        {
          "start_index": 324178,
           "end_index": 324307,
           "text": "For process and program execution security information, security fields were added to struct task_struct and struct linux_binprm."
        },
         {
          "start_index": 324309,
           "end_index": 324395,
           "text": "For filesystem security information, a security field was added to struct super_block."
        }
      ]
    },
     {
      "group_id": 166,
       "duplicates": [
        {
          "start_index": 325656,
           "end_index": 325775,
           "text": "The hook calls can also be easily found in the kernel code by looking for the string &quot;security_ops-&amp;gt;&quot;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 167,
       "duplicates": [
        {
          "start_index": 332609,
           "end_index": 333049,
           "text": "--&gt;1.0.02009-09-06mccInitial revisionRemote Controller API &amp;sub-remote_controllers; &amp;sub-media-controller; &amp;sub-gen-errors; &amp;sub-fdl-appendix; MTD NAND Driver Programming InterfaceThomasGleixnertglx@linutronix.de2004Thomas Gleixner This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 366216,
           "end_index": 366399,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 374186,
           "end_index": 374431,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 377842,
           "end_index": 378098,
           "text": "SCSI Interfaces GuideJamesBottomleyJames.Bottomley@hansenpartnership.comRobLandleyrob@landley.net2007Linux Foundation This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2."
        },
         {
          "start_index": 386014,
           "end_index": 386197,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 386707,
           "end_index": 387174,
           "text": "Memory ManagementSH-4Store Queue API SH-5TLB Interfaces Machine Specific Interfacesmach-dreamcast mach-x3proto BussesSuperHyway Maple The Linux Kernel Tracepoint APIJasonBaronjbaron@redhat.comWilliamCohenwcohen@redhat.com This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 415247,
           "end_index": 415540,
           "text": "Linutronix homepage.The Linux-USB Host Side API This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 445144,
           "end_index": 445428,
           "text": "Copyright (c) 2002-2005 Takashi Iwai tiwai@suse.de This document is free; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 572401,
           "end_index": 572731,
           "text": "Writing USB Device DriversGregKroah-Hartmangreg@kroah.com2001-2002Greg Kroah-Hartman This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        }
      ]
    },
     {
      "group_id": 168,
       "duplicates": [
        {
          "start_index": 368646,
           "end_index": 369542,
           "text": "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction This framework is designed to provide a standard kernel interface to control voltage and current regulators. The intention is to allow systems to dynamically control regulator power output in order to save power and prolong battery life. This applies to both voltage regulators (where voltage output is controllable) and current sinks (where current limit is controllable)."
        },
         {
          "start_index": 586582,
           "end_index": 587396,
           "text": "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux. Introduction The Z85x30 family synchronous/asynchronous controller chips are used on a large number of cheap network interface cards. The kernel provides a core interface layer that is designed to make it easy to provide WAN services using this chip. The current driver only support synchronous operation."
        }
      ]
    },
     {
      "group_id": 169,
       "duplicates": [
        {
          "start_index": 333231,
           "end_index": 333283,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 365350,
           "end_index": 365402,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 366581,
           "end_index": 366633,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 368826,
           "end_index": 368878,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 374613,
           "end_index": 374665,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 386379,
           "end_index": 386431,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 387356,
           "end_index": 387408,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 415722,
           "end_index": 415774,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 445611,
           "end_index": 445663,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 572913,
           "end_index": 572965,
           "text": "See the GNU General Public License for more details."
        },
         {
          "start_index": 586762,
           "end_index": 586814,
           "text": "See the GNU General Public License for more details."
        }
      ]
    },
     {
      "group_id": 170,
       "duplicates": [
        {
          "start_index": 333285,
           "end_index": 333558,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 365404,
           "end_index": 365677,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 366635,
           "end_index": 366908,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 368880,
           "end_index": 369153,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 374667,
           "end_index": 374940,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 378280,
           "end_index": 378354,
           "text": "For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 386433,
           "end_index": 386706,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 387410,
           "end_index": 387683,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 415776,
           "end_index": 416049,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 572967,
           "end_index": 573240,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 586816,
           "end_index": 587089,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        }
      ]
    },
     {
      "group_id": 171,
       "duplicates": [
        {
          "start_index": 333968,
           "end_index": 334065,
           "text": "Each function and struct member has a short description which is marked with an [XXX] identifier."
        },
         {
          "start_index": 363646,
           "end_index": 363730,
           "text": "Each struct member has a short description which is marked with an [XXX] identifier."
        },
         {
          "start_index": 363933,
           "end_index": 364012,
           "text": "Each function has a short description which is marked with an [XXX] identifier."
        },
         {
          "start_index": 364203,
           "end_index": 364282,
           "text": "Each function has a short description which is marked with an [XXX] identifier."
        }
      ]
    },
     {
      "group_id": 172,
       "duplicates": [
        {
          "start_index": 334228,
           "end_index": 334289,
           "text": "The identifiers explain the usage and scope of the functions."
        },
         {
          "start_index": 335338,
           "end_index": 335397,
           "text": "The identifiers explain the usage and scope of the members."
        }
      ]
    },
     {
      "group_id": 173,
       "duplicates": [
        {
          "start_index": 334966,
           "end_index": 335337,
           "text": "The board driver can set the functions which should be replaced by board dependent functions before calling nand_scan(). If the function pointer is NULL on entry to nand_scan() then the pointer is set to the default function which is suitable for the detected chip type. Struct member identifiers [XXX] The struct members are marked with [XXX] identifiers in the comment."
        },
         {
          "start_index": 335738,
           "end_index": 336126,
           "text": "The board driver can set the functions which should be replaced by board dependent functions before calling nand_scan(). If the function pointer is NULL on entry to nand_scan() then the pointer is set to the default function which is suitable for the detected chip type. [BOARDSPECIFIC] Board specific members hold hardware related information which must be provided by the board driver."
        }
      ]
    },
     {
      "group_id": 174,
       "duplicates": [
        {
          "start_index": 338090,
           "end_index": 338159,
           "text": "It&#39;s assumed that the nCE pin is driven by a chip select decoder."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 175,
       "duplicates": [
        {
          "start_index": 338161,
           "end_index": 338792,
           "text": "static void board_hwcontrol(struct mtd_info *mtd, int cmd) { struct nand_chip *this = (struct nand_chip *) mtd-&amp;gt;priv; switch(cmd){ case NAND_CTL_SETCLE: this-&amp;gt;IO_ADDR_W |= CLE_ADRR_BIT; break; case NAND_CTL_CLRCLE: this-&amp;gt;IO_ADDR_W &amp;amp;= ~CLE_ADRR_BIT; break; case NAND_CTL_SETALE: this-&amp;gt;IO_ADDR_W |= ALE_ADRR_BIT; break; case NAND_CTL_CLRALE: this-&amp;gt;IO_ADDR_W &amp;amp;= ~ALE_ADRR_BIT; break; } } Device ready function If the hardware interface has the ready busy pin of the NAND chip connected to a GPIO or other accessible I/O pin, this function is used to read back the state of the pin."
        },
         {
          "start_index": 342623,
           "end_index": 343250,
           "text": "static void board_select_chip (struct mtd_info *mtd, int chip) { struct nand_chip *this = (struct nand_chip *) mtd-&amp;gt;priv; /* Deselect all chips */ this-&amp;gt;IO_ADDR_R &amp;amp;= ~BOARD_NAND_ADDR_MASK; this-&amp;gt;IO_ADDR_W &amp;amp;= ~BOARD_NAND_ADDR_MASK; switch (chip) { case 0: this-&amp;gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIP0; this-&amp;gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIP0; break; .... case n: this-&amp;gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIPn; this-&amp;gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIPn; break; } } Hardware ECC supportFunctions and constants The nand driver supports three different types of hardware ECC."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 176,
       "duplicates": [
        {
          "start_index": 338932,
           "end_index": 339103,
           "text": "If the hardware interface does not give access to the ready busy pin, then the function must not be defined and the function pointer this-&amp;gt;dev_ready is set to NULL."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 177,
       "duplicates": [
        {
          "start_index": 339513,
           "end_index": 340992,
           "text": "static int __init board_init (void) { struct nand_chip *this; int err = 0; /* Allocate memory for MTD device structure and private data */ board_mtd = kzalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL); if (!board_mtd) { printk (&quot;Unable to allocate NAND MTD device structure.\\n&quot;); err = -ENOMEM; goto out; } /* map physical address */ baseaddr = ioremap(CHIP_PHYSICAL_ADDRESS, 1024); if (!baseaddr) { printk(&quot;Ioremap to access NAND chip failed\\n&quot;); err = -EIO; goto out_mtd; } /* Get pointer to private data */ this = (struct nand_chip *) (); /* Link the private data with the MTD structure */ board_mtd-&amp;gt;priv = this; /* Set address of NAND IO lines */ this-&amp;gt;IO_ADDR_R = baseaddr; this-&amp;gt;IO_ADDR_W = baseaddr; /* Reference hardware control function */ this-&amp;gt;hwcontrol = board_hwcontrol; /* Set command delay time, see datasheet for correct value */ this-&amp;gt;chip_delay = CHIP_DEPENDEND_COMMAND_DELAY; /* Assign the device ready function, if available */ this-&amp;gt;dev_ready = board_dev_ready; this-&amp;gt;eccmode = NAND_ECC_SOFT; /* Scan to find existence of the device */ if (nand_scan (board_mtd, 1)) { err = -ENXIO; goto out_ior; } add_mtd_partitions(board_mtd, partition_info, NUM_PARTITIONS); goto out; out_ior: iounmap(baseaddr); out_mtd: kfree (board_mtd); out: return err; } module_init(board_init); Exit function The exit function is only neccecary if the driver is compiled as a module."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 178,
       "duplicates": [
        {
          "start_index": 342213,
           "end_index": 342554,
           "text": "There is no support for parallel arrays which extend the buswidth.GPIO based example static void board_select_chip (struct mtd_info *mtd, int chip) { /* Deselect all chips, set all nCE pins high */ GPIO(BOARD_NAND_NCE) |= 0xff; if (chip &amp;gt;= 0) GPIO(BOARD_NAND_NCE) &amp;amp;= ~ (1 &amp;lt;&amp;lt; chip); } Address lines based example."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 179,
       "duplicates": [
        {
          "start_index": 343251,
           "end_index": 343326,
           "text": "NAND_ECC_HW3_256 Hardware ECC generator providing 3 bytes ECC per 256 byte."
        },
         {
          "start_index": 343327,
           "end_index": 343402,
           "text": "NAND_ECC_HW3_512 Hardware ECC generator providing 3 bytes ECC per 512 byte."
        },
         {
          "start_index": 343403,
           "end_index": 343478,
           "text": "NAND_ECC_HW6_512 Hardware ECC generator providing 6 bytes ECC per 512 byte."
        },
         {
          "start_index": 343479,
           "end_index": 343554,
           "text": "NAND_ECC_HW8_512 Hardware ECC generator providing 6 bytes ECC per 512 byte."
        }
      ]
    },
     {
      "group_id": 180,
       "duplicates": [
        {
          "start_index": 343556,
           "end_index": 343786,
           "text": "If your hardware generator has a different functionality add it at the appropriate place in nand_base.c The board driver must provide following functions: enable_hwecc This function is called before reading / writing to the chip."
        },
         {
          "start_index": 343949,
           "end_index": 344025,
           "text": "calculate_ecc This function is called after read / write from / to the chip."
        }
      ]
    },
     {
      "group_id": 181,
       "duplicates": [
        {
          "start_index": 347037,
           "end_index": 347115,
           "text": "For AG-AND chips this is mandatory, as they have no factory marked bad blocks."
        },
         {
          "start_index": 347116,
           "end_index": 347153,
           "text": "They have factory marked good blocks."
        }
      ]
    },
     {
      "group_id": 182,
       "duplicates": [
        {
          "start_index": 350940,
           "end_index": 351022,
           "text": "It&#39;s highly recommended to enable this for mirrored tables with write support."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 183,
       "duplicates": [
        {
          "start_index": 354245,
           "end_index": 354500,
           "text": "The storage sequence is &amp;lt;spare data page 0&amp;gt;&amp;lt;ecc result 0&amp;gt;...&amp;lt;ecc result n&amp;gt; ... &amp;lt;spare data page n&amp;gt;&amp;lt;ecc result 0&amp;gt;...&amp;lt;ecc result n&amp;gt; This is a legacy mode used by YAFFS1."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 184,
       "duplicates": [
        {
          "start_index": 354502,
           "end_index": 354631,
           "text": "If the spare area buffer is NULL then only the ECC placement is done according to the given scheme in the nand_oobinfo structure."
        },
         {
          "start_index": 354947,
           "end_index": 355056,
           "text": "If the spare area buffer is NULL then only the ECC placement is done according to the default builtin scheme."
        }
      ]
    },
     {
      "group_id": 185,
       "duplicates": [
        {
          "start_index": 355367,
           "end_index": 355962,
           "text": "This applies only to the first page in a block. In the remaining pages this byte is reserved0x06Autoplace 20x07Autoplace 3512 byte pagesizeOffsetContentComment0x00ECC byte 0Error correction code byte 0 of the lower 256 Byte data in this page0x01ECC byte 1Error correction code byte 1 of the lower 256 Bytes of data in this page0x02ECC byte 2Error correction code byte 2 of the lower 256 Bytes of data in this page0x03ECC byte 3Error correction code byte 0 of the upper 256 Bytes of data in this page0x04reservedreserved0x05Bad block markerIf any bit in this byte is zero, then this block is bad."
        },
         {
          "start_index": 355963,
           "end_index": 356367,
           "text": "This applies only to the first page in a block. In the remaining pages this byte is reserved0x06ECC byte 4Error correction code byte 1 of the upper 256 Bytes of data in this page0x07ECC byte 5Error correction code byte 2 of the upper 256 Bytes of data in this page0x08 - 0x0FAutoplace 0 - 72048 byte pagesizeOffsetContentComment0x00Bad block markerIf any bit in this byte is zero, then this block is bad."
        }
      ]
    },
     {
      "group_id": 186,
       "duplicates": [
        {
          "start_index": 359976,
           "end_index": 360034,
           "text": "They are ored together to describe the chip functionality."
        },
         {
          "start_index": 360712,
           "end_index": 360765,
           "text": "They are ored together to describe the functionality."
        }
      ]
    },
     {
      "group_id": 187,
       "duplicates": [
        {
          "start_index": 363731,
           "end_index": 363798,
           "text": "See the chapter &quot;Documentation hints&quot; for an explanation."
        },
         {
          "start_index": 364013,
           "end_index": 364080,
           "text": "See the chapter &quot;Documentation hints&quot; for an explanation."
        },
         {
          "start_index": 364283,
           "end_index": 364350,
           "text": "See the chapter &quot;Documentation hints&quot; for an explanation."
        }
      ]
    },
     {
      "group_id": 188,
       "duplicates": [
        {
          "start_index": 364791,
           "end_index": 365349,
           "text": "The following people have contributed to this document: Thomas Gleixnertglx@linutronix.de Linux Networking and Network Devices APIs This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        },
         {
          "start_index": 366216,
           "end_index": 366580,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        },
         {
          "start_index": 374186,
           "end_index": 374612,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        },
         {
          "start_index": 377842,
           "end_index": 378279,
           "text": "SCSI Interfaces GuideJamesBottomleyJames.Bottomley@hansenpartnership.comRobLandleyrob@landley.net2007Linux Foundation This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        },
         {
          "start_index": 386014,
           "end_index": 386378,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        },
         {
          "start_index": 386707,
           "end_index": 387355,
           "text": "Memory ManagementSH-4Store Queue API SH-5TLB Interfaces Machine Specific Interfacesmach-dreamcast mach-x3proto BussesSuperHyway Maple The Linux Kernel Tracepoint APIJasonBaronjbaron@redhat.comWilliamCohenwcohen@redhat.com This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        },
         {
          "start_index": 415247,
           "end_index": 415721,
           "text": "Linutronix homepage.The Linux-USB Host Side API This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        },
         {
          "start_index": 445144,
           "end_index": 445610,
           "text": "Copyright (c) 2002-2005 Takashi Iwai tiwai@suse.de This document is free; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This document is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        },
         {
          "start_index": 572401,
           "end_index": 572912,
           "text": "Writing USB Device DriversGregKroah-Hartmangreg@kroah.com2001-2002Greg Kroah-Hartman This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
        }
      ]
    },
     {
      "group_id": 189,
       "duplicates": [
        {
          "start_index": 367880,
           "end_index": 368644,
           "text": "Structures Enumeration and Discovery Driver functionality Device model support Sysfs support PPC32 support Credits The following people have contributed to the RapidIO subsystem directly or indirectly: Matt Portermporter@kernel.crashing.orgRandy Vinsonrvinson@mvista.comDan Malekdan@embeddedalley.com The following people have contributed to this document: Matt Portermporter@kernel.crashing.org Voltage and current regulator APILiamGirdwoodlrg@slimlogic.co.ukMarkBrownWolfson Microelectronicsbroonie@opensource.wolfsonmicro.com2007-2008Wolfson Microelectronics2008Liam Girdwood This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 374186,
           "end_index": 374431,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 377842,
           "end_index": 378098,
           "text": "SCSI Interfaces GuideJamesBottomleyJames.Bottomley@hansenpartnership.comRobLandleyrob@landley.net2007Linux Foundation This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2."
        },
         {
          "start_index": 386014,
           "end_index": 386197,
           "text": "This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation."
        },
         {
          "start_index": 386707,
           "end_index": 387174,
           "text": "Memory ManagementSH-4Store Queue API SH-5TLB Interfaces Machine Specific Interfacesmach-dreamcast mach-x3proto BussesSuperHyway Maple The Linux Kernel Tracepoint APIJasonBaronjbaron@redhat.comWilliamCohenwcohen@redhat.com This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 415247,
           "end_index": 415540,
           "text": "Linutronix homepage.The Linux-USB Host Side API This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 445144,
           "end_index": 445428,
           "text": "Copyright (c) 2002-2005 Takashi Iwai tiwai@suse.de This document is free; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        },
         {
          "start_index": 572401,
           "end_index": 572731,
           "text": "Writing USB Device DriversGregKroah-Hartmangreg@kroah.com2001-2002Greg Kroah-Hartman This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
        }
      ]
    },
     {
      "group_id": 190,
       "duplicates": [
        {
          "start_index": 392487,
           "end_index": 392551,
           "text": "You can also use select() on /dev/uioX to wait for an interrupt."
        },
         {
          "start_index": 411150,
           "end_index": 411189,
           "text": "You can also use select() on /dev/uioX."
        }
      ]
    },
     {
      "group_id": 191,
       "duplicates": [
        {
          "start_index": 395916,
           "end_index": 395997,
           "text": "Drivers can set this to make it easier for userspace to find the correct mapping."
        },
         {
          "start_index": 397778,
           "end_index": 397859,
           "text": "Drivers can set it to make it easier for userspace to find a certain port region."
        }
      ]
    },
     {
      "group_id": 192,
       "duplicates": [
        {
          "start_index": 396519,
           "end_index": 396801,
           "text": "To map the memory of mapping N, you have to use N times the page size as your offset: offset = N * getpagesize(); Sometimes there is hardware with memory-like regions that can not be mapped with the technique described here, but there are still ways to access them from userspace."
        },
         {
          "start_index": 410044,
           "end_index": 410246,
           "text": "To map the memory of mapping N, you have to use N times the page size as your offset: offset = N * getpagesize(); N starts from zero, so if you&#39;ve got only one memory range to map, set offset = 0."
        }
      ]
    },
     {
      "group_id": 193,
       "duplicates": [
        {
          "start_index": 398709,
           "end_index": 398747,
           "text": "See the description below for details."
        },
         {
          "start_index": 398934,
           "end_index": 398972,
           "text": "See the description below for details."
        }
      ]
    },
     {
      "group_id": 194,
       "duplicates": [
        {
          "start_index": 399112,
           "end_index": 399252,
           "text": "If you don&#39;t have a hardware generated interrupt but want to trigger the interrupt handler in some other way, set irq to UIO_IRQ_CUSTOM."
        },
         {
          "start_index": 405738,
           "end_index": 405775,
           "text": "That&#39;s what uio_pdrv_genirq does."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 195,
       "duplicates": [
        {
          "start_index": 399352,
           "end_index": 399439,
           "text": "unsigned long irq_flags: Required if you&#39;ve set irq to a hardware interrupt number."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 196,
       "duplicates": [
        {
          "start_index": 399723,
           "end_index": 399790,
           "text": "int (*open)(struct uio_info *info, struct inode *inode) : Optional."
        },
         {
          "start_index": 399897,
           "end_index": 399967,
           "text": "int (*release)(struct uio_info *info, struct inode *inode) : Optional."
        }
      ]
    },
     {
      "group_id": 197,
       "duplicates": [
        {
          "start_index": 401194,
           "end_index": 401263,
           "text": "Note that you must initialize size with zero for all unused mappings."
        },
         {
          "start_index": 402468,
           "end_index": 402536,
           "text": "Note that you must initialize size with zero for all unused regions."
        }
      ]
    },
     {
      "group_id": 198,
       "duplicates": [
        {
          "start_index": 401713,
           "end_index": 401735,
           "text": "Simply leave it alone."
        },
         {
          "start_index": 402679,
           "end_index": 402701,
           "text": "Simply leave it alone."
        }
      ]
    },
     {
      "group_id": 199,
       "duplicates": [
        {
          "start_index": 405042,
           "end_index": 405176,
           "text": "You now have to set the .name element of struct platform_device to &quot;uio_pdrv&quot; to use the generic UIO platform device driver."
        },
         {
          "start_index": 406016,
           "end_index": 406123,
           "text": "You will set the .name element of struct platform_device to &quot;uio_pdrv_genirq&quot; to use this driver."
        },
         {
          "start_index": 407218,
           "end_index": 407316,
           "text": "Set the .name element of struct platform_device to &quot;uio_dmem_genirq&quot; to use this driver."
        }
      ]
    },
     {
      "group_id": 200,
       "duplicates": [
        {
          "start_index": 408611,
           "end_index": 408753,
           "text": "You don&#39;t need any special libraries, your driver can be written in any reasonable language, you can use floating point numbers and so on."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 201,
       "duplicates": [
        {
          "start_index": 411332,
           "end_index": 411431,
           "text": "It can work with any device compliant to PCI 2.3 (circa 2002) and any compliant PCI Express device."
        },
         {
          "start_index": 412961,
           "end_index": 413071,
           "text": "All devices compliant to PCI 2.3 (circa 2002) and all compliant PCI Express devices should support these bits."
        }
      ]
    },
     {
      "group_id": 202,
       "duplicates": [
        {
          "start_index": 411782,
           "end_index": 412088,
           "text": "For example: modprobe uio_pci_generic echo &quot;8086 10f5&quot; &amp;gt; /sys/bus/pci/drivers/uio_pci_generic/new_id If there already is a hardware specific kernel driver for your device, the generic driver still won&#39;t bind to it, in this case if you want to use the generic driver (why would you?)"
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 203,
       "duplicates": [
        {
          "start_index": 412089,
           "end_index": 412678,
           "text": "you&#39;ll have to manually unbind the hardware specific driver and bind the generic driver, like this: echo -n 0000:00:19.0 &amp;gt; /sys/bus/pci/drivers/e1000e/unbind echo -n 0000:00:19.0 &amp;gt; /sys/bus/pci/drivers/uio_pci_generic/bind You can verify that the device has been bound to the driver by looking for it in sysfs, for example like the following: ls -l /sys/bus/pci/devices/0000:00:19.0/driver Which if successful should print .../0000:00:19.0/driver -&amp;gt; ../../../bus/pci/drivers/uio_pci_generic Note that the generic driver will not bind to old PCI 2.2 devices."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 204,
       "duplicates": [
        {
          "start_index": 413674,
           "end_index": 414633,
           "text": "Example code using uio_pci_generic Here is some sample userspace driver code using uio_pci_generic: #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;errno.h&amp;gt; int main() { int uiofd; int configfd; int err; int i; unsigned icount; unsigned char command_high; uiofd = open(&quot;/dev/uio0&quot;, O_RDONLY); if (uiofd &amp;lt; 0) { perror(&quot;uio open:&quot;); return errno; } configfd = open(&quot;/sys/class/uio/uio0/device/config&quot;, O_RDWR); if (configfd &amp;lt; 0) { perror(&quot;config open:&quot;); return errno; } /* Read and cache command value */ err = pread(configfd, &amp;amp;command_high, 1, 5); if (err != 1) { perror(&quot;command config read:&quot;); return errno; } command_high &amp;amp;= ~0x4; for(i = 0;; ++i) { /* Print out a message, for debugging."
        },
         {
          "start_index": 414947,
           "end_index": 415091,
           "text": "*/ err = pwrite(configfd, &amp;amp;command_high, 1, 5); if (err != 1) { perror(&quot;config write:&quot;); break; } /* Wait for next interrupt."
        },
         {
          "start_index": 415092,
           "end_index": 415246,
           "text": "*/ err = read(uiofd, &amp;amp;icount, 4); if (err != 4) { perror(&quot;uio read:&quot;); break; } } return errno; } Further information OSADL homepage."
        },
         {
          "start_index": 458823,
           "end_index": 459106,
           "text": "#include &amp;lt;linux/init.h&amp;gt; #include &amp;lt;linux/pci.h&amp;gt; #include &amp;lt;linux/slab.h&amp;gt; #include &amp;lt;sound/core.h&amp;gt; #include &amp;lt;sound/initval.h&amp;gt; where the last one is necessary only when module options are defined in the source file."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 205,
       "duplicates": [
        {
          "start_index": 420780,
           "end_index": 420931,
           "text": "You&#39;ll probably need to consult the USB 2.0 specification, available online from www.usb.org at no cost, as well as class or device specifications."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 206,
       "duplicates": [
        {
          "start_index": 421822,
           "end_index": 421954,
           "text": "USB-Standard TypesIn &amp;lt;linux/usb/ch9.h&amp;gt; you will find the USB data types defined in chapter 9 of the USB specification."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 207,
       "duplicates": [
        {
          "start_index": 427480,
           "end_index": 427743,
           "text": "That&#39;s the most secure approach for multi-user systems, but for single user systems (&quot;trusted&quot; by that user) it&#39;s more convenient just to grant everyone all access (using the devmode=0666 option) so the driver can start whenever it&#39;s needed."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 208,
       "duplicates": [
        {
          "start_index": 430187,
           "end_index": 430441,
           "text": "You&#39;ll need to convert most multibyte values from little endian format to your native host byte order, although a few of the fields in the device descriptor (both of the BCD-encoded fields, and the vendor and product IDs) will be byteswapped for you."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 209,
       "duplicates": [
        {
          "start_index": 432682,
           "end_index": 432799,
           "text": "Such &quot;periodic&quot; transfers are awkward to use through usbfs, unless you&#39;re using the asynchronous calls."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 210,
       "duplicates": [
        {
          "start_index": 433104,
           "end_index": 433510,
           "text": "The ioctl() RequestsTo use these ioctls, you need to include the following headers in your userspace program: #include &amp;lt;linux/usb.h&amp;gt; #include &amp;lt;linux/usbdevice_fs.h&amp;gt; #include &amp;lt;asm/byteorder.h&amp;gt; The standard USB device model requests, from &quot;Chapter 9&quot; of the USB 2.0 specification, are automatically included from the &amp;lt;linux/usb/ch9.h&amp;gt; header."
        },
         {
          "start_index": 458823,
           "end_index": 459106,
           "text": "#include &amp;lt;linux/init.h&amp;gt; #include &amp;lt;linux/pci.h&amp;gt; #include &amp;lt;linux/slab.h&amp;gt; #include &amp;lt;sound/core.h&amp;gt; #include &amp;lt;sound/initval.h&amp;gt; where the last one is necessary only when module options are defined in the source file."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 211,
       "duplicates": [
        {
          "start_index": 434762,
           "end_index": 434867,
           "text": "The ioctl parameter is an integer holding the number of the interface (bInterfaceNumber from descriptor)."
        },
         {
          "start_index": 437366,
           "end_index": 437526,
           "text": "The ioctl parameter is an integer holding the number of the interface (bInterfaceNumber from descriptor); File modification time is not updated by this request."
        },
         {
          "start_index": 440919,
           "end_index": 440973,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 441823,
           "end_index": 441877,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 444457,
           "end_index": 444534,
           "text": "USBDEVFS_DISCARDURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444536,
           "end_index": 444613,
           "text": "USBDEVFS_DISCSIGNALTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444615,
           "end_index": 444689,
           "text": "USBDEVFS_REAPURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444691,
           "end_index": 444771,
           "text": "USBDEVFS_REAPURBNDELAYTBS File modification time is not updated by this request."
        }
      ]
    },
     {
      "group_id": 212,
       "duplicates": [
        {
          "start_index": 435152,
           "end_index": 435206,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 440919,
           "end_index": 440973,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 441823,
           "end_index": 441877,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 444457,
           "end_index": 444534,
           "text": "USBDEVFS_DISCARDURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444536,
           "end_index": 444613,
           "text": "USBDEVFS_DISCSIGNALTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444615,
           "end_index": 444689,
           "text": "USBDEVFS_REAPURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444691,
           "end_index": 444771,
           "text": "USBDEVFS_REAPURBNDELAYTBS File modification time is not updated by this request."
        }
      ]
    },
     {
      "group_id": 213,
       "duplicates": [
        {
          "start_index": 435264,
           "end_index": 435448,
           "text": "The ioctl parameter points to a structure like this: struct usbdevfs_connectinfo { unsigned int devnum; unsigned char slow; }; File modification time is not updated by this request."
        },
         {
          "start_index": 440919,
           "end_index": 440973,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 441823,
           "end_index": 441877,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 444457,
           "end_index": 444534,
           "text": "USBDEVFS_DISCARDURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444536,
           "end_index": 444613,
           "text": "USBDEVFS_DISCSIGNALTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444615,
           "end_index": 444689,
           "text": "USBDEVFS_REAPURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444691,
           "end_index": 444771,
           "text": "USBDEVFS_REAPURBNDELAYTBS File modification time is not updated by this request."
        }
      ]
    },
     {
      "group_id": 214,
       "duplicates": [
        {
          "start_index": 435449,
           "end_index": 435581,
           "text": "You can&#39;t tell whether a &quot;not slow&quot; device is connected at high speed (480 MBit/sec) or just full speed (12 MBit/sec)."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 215,
       "duplicates": [
        {
          "start_index": 435768,
           "end_index": 435989,
           "text": "Parameter is a pointer to this structure, which is modified: struct usbdevfs_getdriver { unsigned int interface; char driver[USBDEVFS_MAXDRIVERNAME + 1]; }; File modification time is not updated by this request."
        },
         {
          "start_index": 440919,
           "end_index": 440973,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 441823,
           "end_index": 441877,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 444457,
           "end_index": 444534,
           "text": "USBDEVFS_DISCARDURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444536,
           "end_index": 444613,
           "text": "USBDEVFS_DISCSIGNALTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444615,
           "end_index": 444689,
           "text": "USBDEVFS_REAPURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444691,
           "end_index": 444771,
           "text": "USBDEVFS_REAPURBNDELAYTBS File modification time is not updated by this request."
        }
      ]
    },
     {
      "group_id": 216,
       "duplicates": [
        {
          "start_index": 436239,
           "end_index": 436319,
           "text": "* &#39;request&#39; becomes the driver-&amp;gt;ioctl() &#39;code&#39; parameter."
        },
         {
          "start_index": 436320,
           "end_index": 436471,
           "text": "* the size of &#39;param&#39; is encoded in &#39;request&#39;, and that data * is copied to or from the driver-&amp;gt;ioctl() &#39;buf&#39; parameter."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 217,
       "duplicates": [
        {
          "start_index": 436472,
           "end_index": 436769,
           "text": "*/ static int usbdev_ioctl (int fd, int ifno, unsigned request, void *param) { struct usbdevfs_ioctl wrapper; wrapper.ifno = ifno; wrapper.ioctl_code = request; wrapper.data = param; return ioctl (fd, USBDEVFS_IOCTL, &amp;amp;wrapper); } File modification time is not updated by this request."
        },
         {
          "start_index": 440919,
           "end_index": 440973,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 441823,
           "end_index": 441877,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 444457,
           "end_index": 444534,
           "text": "USBDEVFS_DISCARDURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444536,
           "end_index": 444613,
           "text": "USBDEVFS_DISCSIGNALTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444615,
           "end_index": 444689,
           "text": "USBDEVFS_REAPURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444691,
           "end_index": 444771,
           "text": "USBDEVFS_REAPURBNDELAYTBS File modification time is not updated by this request."
        }
      ]
    },
     {
      "group_id": 218,
       "duplicates": [
        {
          "start_index": 436926,
           "end_index": 437020,
           "text": "It&#39;s also been used to do things like ask devices what device special file should be used."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 219,
       "duplicates": [
        {
          "start_index": 437783,
           "end_index": 437960,
           "text": "The ioctl parameter is an integer endpoint number (1 to 15, as identified in the endpoint descriptor), with USB_DIR_IN added if the device&#39;s endpoint sends data to the host."
        },
         {
          "start_index": 439351,
           "end_index": 439551,
           "text": "The ioctl parameter is an integer endpoint number (1 to 15, as identified in an endpoint descriptor), masked with USB_DIR_IN when referring to an endpoint which sends data to the host from the device."
        }
      ]
    },
     {
      "group_id": 220,
       "duplicates": [
        {
          "start_index": 438622,
           "end_index": 439139,
           "text": "The ioctl parameter is a pointer to this structure: struct usbdevfs_bulktransfer { unsigned int ep; unsigned int len; unsigned int timeout; /* in milliseconds */ void *data; }; The &quot;ep&quot; value identifies a bulk endpoint number (1 to 15, as identified in an endpoint descriptor), masked with USB_DIR_IN when referring to an endpoint which sends data to the host from the device. The length of the data buffer is identified by &quot;len&quot;; Recent kernels support requests up to about 128KBytes."
        },
         {
          "start_index": 439351,
           "end_index": 439664,
           "text": "The ioctl parameter is an integer endpoint number (1 to 15, as identified in an endpoint descriptor), masked with USB_DIR_IN when referring to an endpoint which sends data to the host from the device. Use this on bulk or interrupt endpoints which have stalled, returning -EPIPE status to a data transfer request."
        }
      ]
    },
     {
      "group_id": 221,
       "duplicates": [
        {
          "start_index": 440205,
           "end_index": 440351,
           "text": "The bRequestType value is composed by combining a USB_TYPE_* value, a USB_DIR_* value, and a USB_RECIP_* value (from &amp;lt;linux/usb.h&amp;gt;)."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 222,
       "duplicates": [
        {
          "start_index": 440974,
           "end_index": 441186,
           "text": "Avoid using this call until some usbcore bugs get fixed, since it does not fully synchronize device, interface, and driver (not just usbfs) state. USBDEVFS_SETINTERFACESets the alternate setting for an interface."
        },
         {
          "start_index": 441878,
           "end_index": 442170,
           "text": "Avoid using this call until some usbcore bugs get fixed, since it does not fully synchronize device, interface, and driver (not just usbfs) state. Asynchronous I/O SupportAs mentioned above, there are situations where it may be important to initiate concurrent operations from user mode code."
        }
      ]
    },
     {
      "group_id": 223,
       "duplicates": [
        {
          "start_index": 441188,
           "end_index": 441386,
           "text": "The ioctl parameter is a pointer to a structure like this: struct usbdevfs_setinterface { unsigned int interface; unsigned int altsetting; }; File modification time is not updated by this request."
        },
         {
          "start_index": 441823,
           "end_index": 441877,
           "text": "File modification time is not updated by this request."
        },
         {
          "start_index": 444457,
           "end_index": 444534,
           "text": "USBDEVFS_DISCARDURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444536,
           "end_index": 444613,
           "text": "USBDEVFS_DISCSIGNALTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444615,
           "end_index": 444689,
           "text": "USBDEVFS_REAPURBTBS File modification time is not updated by this request."
        },
         {
          "start_index": 444691,
           "end_index": 444771,
           "text": "USBDEVFS_REAPURBNDELAYTBS File modification time is not updated by this request."
        }
      ]
    },
     {
      "group_id": 224,
       "duplicates": [
        {
          "start_index": 447008,
           "end_index": 447384,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- File Tree Structure --&gt;&lt;!-- ****************************************************** --&gt;File Tree StructureGeneral The ALSA drivers are provided in two ways. One is the trees provided as a tarball or via cvs from the ALSA&#39;s ftp site, and another is the 2.6 (or later) Linux kernel tree."
        },
         {
          "start_index": 459637,
           "end_index": 459978,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Management of Cards and Components --&gt;&lt;!-- ****************************************************** --&gt;Management of Cards and ComponentsCard Instance For each soundcard, a card record must be allocated. A card record is the headquarters of the soundcard."
        },
         {
          "start_index": 514857,
           "end_index": 515158,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Control Interface --&gt;&lt;!-- ****************************************************** --&gt;Control InterfaceGeneral The control interface is used widely for many switches, sliders, etc. which are accessed from user-space."
        },
         {
          "start_index": 559377,
           "end_index": 559759,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Power Management --&gt;&lt;!-- ****************************************************** --&gt;Power Management If the chip is supposed to work with suspend/resume functions, you need to add power-management code to the driver. The additional code for power-management should be ifdef&#39;ed with CONFIG_PM."
        },
         {
          "start_index": 571943,
           "end_index": 572295,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document. Kevin Conder reformatted the original plain-text to the DocBook format."
        }
      ]
    },
     {
      "group_id": 225,
       "duplicates": [
        {
          "start_index": 445665,
           "end_index": 446121,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA &lt;!-- ****************************************************** --&gt;&lt;!-- Preface --&gt;&lt;!-- ****************************************************** --&gt;Preface This document describes how to write an ALSA (Advanced Linux Sound Architecture) driver."
        },
         {
          "start_index": 447008,
           "end_index": 447250,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- File Tree Structure --&gt;&lt;!-- ****************************************************** --&gt;File Tree StructureGeneral The ALSA drivers are provided in two ways."
        },
         {
          "start_index": 459637,
           "end_index": 459925,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Management of Cards and Components --&gt;&lt;!-- ****************************************************** --&gt;Management of Cards and ComponentsCard Instance For each soundcard, a card record must be allocated."
        },
         {
          "start_index": 476474,
           "end_index": 476810,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- PCM Interface --&gt;&lt;!-- ****************************************************** --&gt;PCM InterfaceGeneral The PCM middle layer of ALSA is quite powerful and it is only necessary for each driver to implement the low-level functions to access its hardware."
        },
         {
          "start_index": 514857,
           "end_index": 515122,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Control Interface --&gt;&lt;!-- ****************************************************** --&gt;Control InterfaceGeneral The control interface is used widely for many switches, sliders, etc."
        },
         {
          "start_index": 532245,
           "end_index": 532523,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- MIDI (MPU401-UART) Interface --&gt;&lt;!-- ****************************************************** --&gt;MIDI (MPU401-UART) InterfaceGeneral Many soundcards have built-in MIDI (MPU401-UART) interfaces."
        },
         {
          "start_index": 542229,
           "end_index": 542509,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Miscellaneous Devices --&gt;&lt;!-- ****************************************************** --&gt;Miscellaneous DevicesFM OPL3 The FM OPL3 is still used in many chips (mainly for backward compatibility)."
        },
         {
          "start_index": 547435,
           "end_index": 547760,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Buffer and Memory Management --&gt;&lt;!-- ****************************************************** --&gt;Buffer and Memory ManagementBuffer Types ALSA provides several different buffer allocation functions depending on the bus and the architecture."
        },
         {
          "start_index": 559377,
           "end_index": 559679,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Power Management --&gt;&lt;!-- ****************************************************** --&gt;Power Management If the chip is supposed to work with suspend/resume functions, you need to add power-management code to the driver."
        },
         {
          "start_index": 570159,
           "end_index": 570427,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends ALSA provides a verbose version of the printk() function."
        },
         {
          "start_index": 571943,
           "end_index": 572222,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document."
        },
         {
          "start_index": 572967,
           "end_index": 573240,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        },
         {
          "start_index": 586816,
           "end_index": 587089,
           "text": "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA For more details see the file COPYING in the source distribution of Linux."
        }
      ]
    },
     {
      "group_id": 226,
       "duplicates": [
        {
          "start_index": 448211,
           "end_index": 448255,
           "text": "It&#39;s named as acore in alsa-driver tree."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 227,
       "duplicates": [
        {
          "start_index": 450813,
           "end_index": 450954,
           "text": "pci directory This directory and its sub-directories hold the top-level card modules for PCI soundcards and the code specific to the PCI BUS."
        },
         {
          "start_index": 451145,
           "end_index": 451249,
           "text": "isa directory This directory and its sub-directories hold the top-level card modules for ISA soundcards."
        }
      ]
    },
     {
      "group_id": 228,
       "duplicates": [
        {
          "start_index": 451778,
           "end_index": 452463,
           "text": "In the ALSA driver tarball, this directory is empty, of course :) &lt;!-- ****************************************************** --&gt;&lt;!-- Basic Flow for PCI Drivers --&gt;&lt;!-- ****************************************************** --&gt;Basic Flow for PCI DriversOutline The minimum flow for PCI soundcards is as follows: define the PCI ID table (see the section PCI Entries ).create probe() callback.create remove() callback.create a pci_driver structure containing the three pointers above.create an init() function just calling the pci_register_driver() to register the pci_driver table defined above.create an exit() function to call the pci_unregister_driver() function."
        },
         {
          "start_index": 459637,
           "end_index": 459925,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Management of Cards and Components --&gt;&lt;!-- ****************************************************** --&gt;Management of Cards and ComponentsCard Instance For each soundcard, a card record must be allocated."
        },
         {
          "start_index": 476474,
           "end_index": 476810,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- PCM Interface --&gt;&lt;!-- ****************************************************** --&gt;PCM InterfaceGeneral The PCM middle layer of ALSA is quite powerful and it is only necessary for each driver to implement the low-level functions to access its hardware."
        },
         {
          "start_index": 514857,
           "end_index": 515122,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Control Interface --&gt;&lt;!-- ****************************************************** --&gt;Control InterfaceGeneral The control interface is used widely for many switches, sliders, etc."
        },
         {
          "start_index": 532245,
           "end_index": 532523,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- MIDI (MPU401-UART) Interface --&gt;&lt;!-- ****************************************************** --&gt;MIDI (MPU401-UART) InterfaceGeneral Many soundcards have built-in MIDI (MPU401-UART) interfaces."
        },
         {
          "start_index": 542229,
           "end_index": 542509,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Miscellaneous Devices --&gt;&lt;!-- ****************************************************** --&gt;Miscellaneous DevicesFM OPL3 The FM OPL3 is still used in many chips (mainly for backward compatibility)."
        },
         {
          "start_index": 547435,
           "end_index": 547760,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Buffer and Memory Management --&gt;&lt;!-- ****************************************************** --&gt;Buffer and Memory ManagementBuffer Types ALSA provides several different buffer allocation functions depending on the bus and the architecture."
        },
         {
          "start_index": 559377,
           "end_index": 559679,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Power Management --&gt;&lt;!-- ****************************************************** --&gt;Power Management If the chip is supposed to work with suspend/resume functions, you need to add power-management code to the driver."
        },
         {
          "start_index": 570159,
           "end_index": 570427,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends ALSA provides a verbose version of the printk() function."
        },
         {
          "start_index": 571943,
           "end_index": 572222,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document."
        }
      ]
    },
     {
      "group_id": 229,
       "duplicates": [
        {
          "start_index": 452727,
           "end_index": 457088,
           "text": "Basic Flow for PCI Drivers - Example #include &amp;lt;linux/init.h&amp;gt; #include &amp;lt;linux/pci.h&amp;gt; #include &amp;lt;linux/slab.h&amp;gt; #include &amp;lt;sound/core.h&amp;gt; #include &amp;lt;sound/initval.h&amp;gt; /* module parameters (see &quot;Module Parameters&quot;) */ /* SNDRV_CARDS: maximum number of cards supported by this module */ static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX; static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR; static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP; /* definition of the chip-specific record */ struct mychip { struct snd_card *card; /* the rest of the implementation will be in section * &quot;PCI Resource Management&quot; */ }; /* chip-specific destructor * (see &quot;PCI Resource Management&quot;) */ static int snd_mychip_free(struct mychip *chip) { .... /* will be implemented later... */ } /* component-destructor * (see &quot;Management of Cards and Components&quot;) */ static int snd_mychip_dev_free(struct snd_device *device) { return snd_mychip_free(device-&amp;gt;device_data); } /* chip-specific constructor * (see &quot;Management of Cards and Components&quot;) */ static int snd_mychip_create(struct snd_card *card, struct pci_dev *pci, struct mychip **rchip) { struct mychip *chip; int err; static struct snd_device_ops ops = { .dev_free = snd_mychip_dev_free, }; *rchip = NULL; /* check PCI availability here * (see &quot;PCI Resource Management&quot;) */ .... /* allocate a chip-specific data with zero filled */ chip = kzalloc(sizeof(*chip), GFP_KERNEL); if (chip == NULL) return -ENOMEM; chip-&amp;gt;card = card; /* rest of initialization here; will be implemented * later, see &quot;PCI Resource Management&quot; */ .... err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;amp;ops); if (err &amp;lt; 0) { snd_mychip_free(chip); return err; } snd_card_set_dev(card, &amp;amp;pci-&amp;gt;dev); *rchip = chip; return 0; } /* constructor -- see &quot;Constructor&quot; sub-section */ static int snd_mychip_probe(struct pci_dev *pci, const struct pci_device_id *pci_id) { static int dev; struct snd_card *card; struct mychip *chip; int err; /* (1) */ if (dev &amp;gt;= SNDRV_CARDS) return -ENODEV; if (!enable[dev]) { dev++; return -ENOENT; } /* (2) */ err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;amp;card); if (err &amp;lt; 0) return err; /* (3) */ err = snd_mychip_create(card, pci, &amp;amp;chip); if (err &amp;lt; 0) { snd_card_free(card); return err; } /* (4) */ strcpy(card-&amp;gt;driver, &quot;My Chip&quot;); strcpy(card-&amp;gt;shortname, &quot;My Own Chip 123&quot;); sprintf(card-&amp;gt;longname, &quot;%s at 0x%lx irq %i&quot;, card-&amp;gt;shortname, chip-&amp;gt;ioport, chip-&amp;gt;irq); /* (5) */ .... /* implemented later */ /* (6) */ err = snd_card_register(card); if (err &amp;lt; 0) { snd_card_free(card); return err; } /* (7) */ pci_set_drvdata(pci, card); dev++; return 0; } /* destructor -- see the &quot;Destructor&quot; sub-section */ static void snd_mychip_remove(struct pci_dev *pci) { snd_card_free(pci_get_drvdata(pci)); pci_set_drvdata(pci, NULL); } Constructor The real constructor of PCI drivers is the probe callback. The probe callback and other component-constructors which are called from the probe callback cannot be used with the __init prefix because any PCI device could be a hotplug device. In the probe callback, the following scheme is often used. 1) Check and increment the device index. static int dev; .... if (dev &amp;gt;= SNDRV_CARDS) return -ENODEV; if (!enable[dev]) { dev++; return -ENOENT; } where enable[dev] is the module option. Each time the probe callback is called, check the availability of the device. If not available, simply increment the device index and returns. dev will be incremented also later (step 7). 2) Create a card instance struct snd_card *card; int err; .... err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;amp;card); The details will be explained in the section Management of Cards and Components. 3) Create a main component In this part, the PCI resources are allocated. struct mychip *chip; .... err = snd_mychip_create(card, pci, &amp;amp;chip); if (err &amp;lt; 0) { snd_card_free(card); return err; } The details will be explained in the section PCI Resource Management. 4) Set the driver ID and name strings."
        },
         {
          "start_index": 457089,
           "end_index": 458112,
           "text": "strcpy(card-&amp;gt;driver, &quot;My Chip&quot;); strcpy(card-&amp;gt;shortname, &quot;My Own Chip 123&quot;); sprintf(card-&amp;gt;longname, &quot;%s at 0x%lx irq %i&quot;, card-&amp;gt;shortname, chip-&amp;gt;ioport, chip-&amp;gt;irq); The driver field holds the minimal ID string of the chip. This is used by alsa-lib&#39;s configurator, so keep it simple but unique. Even the same driver can have different driver IDs to distinguish the functionality of each chip type. The shortname field is a string shown as more verbose name. The longname field contains the information shown in /proc/asound/cards. 5) Create other components, such as mixer, MIDI, etc. Here you define the basic components such as PCM, mixer (e.g. AC97), MIDI (e.g. MPU-401), and other interfaces. Also, if you want a proc file, define it here, too. 6) Register the card instance. err = snd_card_register(card); if (err &amp;lt; 0) { snd_card_free(card); return err; } Will be explained in the section Management of Cards and Components, too."
        }
      ]
    },
     {
      "group_id": 230,
       "duplicates": [
        {
          "start_index": 458823,
           "end_index": 459106,
           "text": "#include &amp;lt;linux/init.h&amp;gt; #include &amp;lt;linux/pci.h&amp;gt; #include &amp;lt;linux/slab.h&amp;gt; #include &amp;lt;sound/core.h&amp;gt; #include &amp;lt;sound/initval.h&amp;gt; where the last one is necessary only when module options are defined in the source file."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 231,
       "duplicates": [
        {
          "start_index": 459353,
           "end_index": 459461,
           "text": "If you use the mdelay() or udelay() functions, you&#39;ll need to include &amp;lt;linux/delay.h&amp;gt; too."
        },
         {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 232,
       "duplicates": [
        {
          "start_index": 515430,
           "end_index": 515548,
           "text": "The control API is defined in &amp;lt;sound/control.h&amp;gt;. Include this file if you want to add your own controls."
        },
         {
          "start_index": 542554,
           "end_index": 542722,
           "text": "The OPL3 API is defined in &amp;lt;sound/opl3.h&amp;gt;. FM registers can be directly accessed through the direct-FM API, defined in &amp;lt;sound/asound_fm.h&amp;gt;."
        }
      ]
    },
     {
      "group_id": 233,
       "duplicates": [
        {
          "start_index": 459576,
           "end_index": 459636,
           "text": "They have to be included after &amp;lt;sound/core.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 234,
       "duplicates": [
        {
          "start_index": 460745,
           "end_index": 460842,
           "text": "The extra_size argument is used to allocate card-&amp;gt;private_data for the chip-specific data."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 235,
       "duplicates": [
        {
          "start_index": 462079,
           "end_index": 462163,
           "text": "Hence, you don&#39;t need to take care of calling a destructor for such a component."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 236,
       "duplicates": [
        {
          "start_index": 462944,
           "end_index": 463104,
           "text": "In return, the allocated record can be accessed as struct mychip *chip = card-&amp;gt;private_data; With this method, you don&#39;t have to allocate twice."
        },
         {
          "start_index": 498152,
           "end_index": 498201,
           "text": "Don&#39;t mix this with pcm-&amp;gt;private_data."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 237,
       "duplicates": [
        {
          "start_index": 463646,
           "end_index": 464023,
           "text": "chip-&amp;gt;card = card; Next, initialize the fields, and register this chip record as a low-level device with a specified ops, static struct snd_device_ops ops = { .dev_free = snd_mychip_dev_free, }; .... snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;amp;ops); snd_mychip_dev_free() is the device-destructor function, which will call the real destructor."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 238,
       "duplicates": [
        {
          "start_index": 464025,
           "end_index": 464189,
           "text": "static int snd_mychip_dev_free(struct snd_device *device) { return snd_mychip_free(device-&amp;gt;device_data); } where snd_mychip_free() is the real destructor."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 239,
       "duplicates": [
        {
          "start_index": 464856,
           "end_index": 465204,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- PCI Resource Management --&gt;&lt;!-- ****************************************************** --&gt;PCI Resource ManagementFull Code Example In this section, we&#39;ll complete the chip-specific constructor, destructor and PCI entries. Example code is shown first, below."
        },
         {
          "start_index": 547435,
           "end_index": 547793,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Buffer and Memory Management --&gt;&lt;!-- ****************************************************** --&gt;Buffer and Memory ManagementBuffer Types ALSA provides several different buffer allocation functions depending on the bus and the architecture. All these have a consistent API."
        }
      ]
    },
     {
      "group_id": 240,
       "duplicates": [
        {
          "start_index": 465206,
           "end_index": 468466,
           "text": "PCI Resource Management Example struct mychip { struct snd_card *card; struct pci_dev *pci; unsigned long port; int irq; }; static int snd_mychip_free(struct mychip *chip) { /* disable hardware here if any */ .... /* (not implemented in this document) */ /* release the irq */ if (chip-&amp;gt;irq &amp;gt;= 0) free_irq(chip-&amp;gt;irq, chip); /* release the I/O ports &amp;amp; memory */ pci_release_regions(chip-&amp;gt;pci); /* disable the PCI entry */ pci_disable_device(chip-&amp;gt;pci); /* release the data */ kfree(chip); return 0; } /* chip-specific constructor */ static int snd_mychip_create(struct snd_card *card, struct pci_dev *pci, struct mychip **rchip) { struct mychip *chip; int err; static struct snd_device_ops ops = { .dev_free = snd_mychip_dev_free, }; *rchip = NULL; /* initialize the PCI entry */ err = pci_enable_device(pci); if (err &amp;lt; 0) return err; /* check PCI availability (28bit DMA) */ if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &amp;lt; 0 || pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &amp;lt; 0) { printk(KERN_ERR &quot;error to set 28bit mask DMA\\n&quot;); pci_disable_device(pci); return -ENXIO; } chip = kzalloc(sizeof(*chip), GFP_KERNEL); if (chip == NULL) { pci_disable_device(pci); return -ENOMEM; } /* initialize the stuff */ chip-&amp;gt;card = card; chip-&amp;gt;pci = pci; chip-&amp;gt;irq = -1; /* (1) PCI resource allocation */ err = pci_request_regions(pci, &quot;My Chip&quot;); if (err &amp;lt; 0) { kfree(chip); pci_disable_device(pci); return err; } chip-&amp;gt;port = pci_resource_start(pci, 0); if (request_irq(pci-&amp;gt;irq, snd_mychip_interrupt, IRQF_SHARED, KBUILD_MODNAME, chip)) { printk(KERN_ERR &quot;cannot grab irq %d\\n&quot;, pci-&amp;gt;irq); snd_mychip_free(chip); return -EBUSY; } chip-&amp;gt;irq = pci-&amp;gt;irq; /* (2) initialization of the chip hardware */ .... /* (not implemented in this document) */ err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;amp;ops); if (err &amp;lt; 0) { snd_mychip_free(chip); return err; } snd_card_set_dev(card, &amp;amp;pci-&amp;gt;dev); *rchip = chip; return 0; } /* PCI IDs */ static struct pci_device_id snd_mychip_ids[] = { { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, }, .... { 0, } }; MODULE_DEVICE_TABLE(pci, snd_mychip_ids); /* pci_driver definition */ static struct pci_driver driver = { .name = KBUILD_MODNAME, .id_table = snd_mychip_ids, .probe = snd_mychip_probe, .remove = snd_mychip_remove, }; /* module initialization */ static int __init alsa_card_mychip_init(void) { return pci_register_driver(&amp;amp;driver); } /* module clean up */ static void __exit alsa_card_mychip_exit(void) { pci_unregister_driver(&amp;amp;driver); } module_init(alsa_card_mychip_init) module_exit(alsa_card_mychip_exit) EXPORT_NO_SYMBOLS; /* for old kernels only */ Some Hafta&#39;s The allocation of PCI resources is done in the probe() function, and usually an extra xxx_create() function is written for this purpose. In the case of PCI devices, you first have to call the pci_enable_device() function before allocating resources. Also, you need to set the proper PCI DMA mask to limit the accessed I/O range. In some cases, you might need to call pci_set_master() function, too."
        },
         {
          "start_index": 468468,
           "end_index": 469144,
           "text": "Suppose the 28bit mask, and the code to be added would be like: err = pci_enable_device(pci); if (err &amp;lt; 0) return err; if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &amp;lt; 0 || pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &amp;lt; 0) { printk(KERN_ERR &quot;error to set 28bit mask DMA\\n&quot;); pci_disable_device(pci); return -ENXIO; } Resource Allocation The allocation of I/O ports and irqs is done via standard kernel functions. Unlike ALSA ver.0.5.x., there are no helpers for that. And these resources must be released in the destructor function (see below). Also, on ALSA 0.9.x, you don&#39;t need to allocate (pseudo-)DMA for PCI like in ALSA 0.5.x."
        },
         {
          "start_index": 469777,
           "end_index": 470303,
           "text": "The allocation of an I/O port is done like this: err = pci_request_regions(pci, &quot;My Chip&quot;); if (err &amp;lt; 0) { kfree(chip); pci_disable_device(pci); return err; } chip-&amp;gt;port = pci_resource_start(pci, 0); &lt;!-- obsolete --&gt; It will reserve the I/O port region of 8 bytes of the given PCI device. The returned value, chip-&amp;gt;res_port, is allocated via kmalloc() by request_region(). The pointer must be released via kfree(), but there is a problem with this. This issue will be explained later."
        },
         {
          "start_index": 470305,
           "end_index": 470861,
           "text": "The allocation of an interrupt source is done like this: if (request_irq(pci-&amp;gt;irq, snd_mychip_interrupt, IRQF_SHARED, KBUILD_MODNAME, chip)) { printk(KERN_ERR &quot;cannot grab irq %d\\n&quot;, pci-&amp;gt;irq); snd_mychip_free(chip); return -EBUSY; } chip-&amp;gt;irq = pci-&amp;gt;irq; where snd_mychip_interrupt() is the interrupt handler defined later. Note that chip-&amp;gt;irq should be defined only when request_irq() succeeded. On the PCI bus, interrupts can be shared. Thus, IRQF_SHARED is used as the interrupt flag of request_irq()."
        }
      ]
    },
     {
      "group_id": 241,
       "duplicates": [
        {
          "start_index": 471158,
           "end_index": 471414,
           "text": "The interrupt handler looks usually like the following: static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id) { struct mychip *chip = dev_id; .... return IRQ_HANDLED; } Now let&#39;s write the corresponding destructor for the resources above."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 242,
       "duplicates": [
        {
          "start_index": 471669,
           "end_index": 471880,
           "text": "For the interrupt, do like this: if (chip-&amp;gt;irq &amp;gt;= 0) free_irq(chip-&amp;gt;irq, chip); Since the irq number can start from 0, you should initialize chip-&amp;gt;irq with a negative value (e.g."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 243,
       "duplicates": [
        {
          "start_index": 472176,
           "end_index": 472332,
           "text": "pci_release_regions(chip-&amp;gt;pci); When you requested manually via request_region() or request_mem_region, you can release it via release_resource()."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 244,
       "duplicates": [
        {
          "start_index": 472334,
           "end_index": 472584,
           "text": "Suppose that you keep the resource pointer returned from request_region() in chip-&amp;gt;res_port, the release procedure looks like: release_and_free_resource(chip-&amp;gt;res_port); Don&#39;t forget to call pci_disable_device() before the end."
        },
         {
          "start_index": 498152,
           "end_index": 498201,
           "text": "Don&#39;t mix this with pcm-&amp;gt;private_data."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 245,
       "duplicates": [
        {
          "start_index": 472635,
           "end_index": 472716,
           "text": "kfree(chip); We didn&#39;t implement the hardware disabling part in the above."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 246,
       "duplicates": [
        {
          "start_index": 473179,
           "end_index": 473216,
           "text": "You don&#39;t have to stop PCMs, etc."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 247,
       "duplicates": [
        {
          "start_index": 473366,
           "end_index": 474246,
           "text": "You&#39;ll need three fields like the following: struct mychip { .... unsigned long iobase_phys; void __iomem *iobase_virt; }; and the allocation would be like below: if ((err = pci_request_regions(pci, &quot;My Chip&quot;)) &amp;lt; 0) { kfree(chip); return err; } chip-&amp;gt;iobase_phys = pci_resource_start(pci, 0); chip-&amp;gt;iobase_virt = ioremap_nocache(chip-&amp;gt;iobase_phys, pci_resource_len(pci, 0)); and the corresponding destructor would be: static int snd_mychip_free(struct mychip *chip) { .... if (chip-&amp;gt;iobase_virt) iounmap(chip-&amp;gt;iobase_virt); .... pci_release_regions(chip-&amp;gt;pci); .... } Registration of Device Struct At some point, typically after calling snd_device_new(), you need to register the struct device of the chip you&#39;re handling for udev and co. ALSA provides a macro for compatibility with older kernels."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 248,
       "duplicates": [
        {
          "start_index": 474248,
           "end_index": 474392,
           "text": "Simply call like the following: snd_card_set_dev(card, &amp;amp;pci-&amp;gt;dev); so that it stores the PCI&#39;s device pointer to the card."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 249,
       "duplicates": [
        {
          "start_index": 474667,
           "end_index": 474706,
           "text": "Let&#39;s finish the missing PCI stuff."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 250,
       "duplicates": [
        {
          "start_index": 474765,
           "end_index": 474829,
           "text": "It&#39;s a table of PCI vendor/device ID number, and some masks."
        },
         {
          "start_index": 476436,
           "end_index": 476473,
           "text": "EXPORT_NO_SYMBOLS; That&#39;s all!"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 251,
       "duplicates": [
        {
          "start_index": 476474,
           "end_index": 476810,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- PCM Interface --&gt;&lt;!-- ****************************************************** --&gt;PCM InterfaceGeneral The PCM middle layer of ALSA is quite powerful and it is only necessary for each driver to implement the low-level functions to access its hardware."
        },
         {
          "start_index": 514857,
           "end_index": 515122,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Control Interface --&gt;&lt;!-- ****************************************************** --&gt;Control InterfaceGeneral The control interface is used widely for many switches, sliders, etc."
        },
         {
          "start_index": 532245,
           "end_index": 532523,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- MIDI (MPU401-UART) Interface --&gt;&lt;!-- ****************************************************** --&gt;MIDI (MPU401-UART) InterfaceGeneral Many soundcards have built-in MIDI (MPU401-UART) interfaces."
        },
         {
          "start_index": 542229,
           "end_index": 542509,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Miscellaneous Devices --&gt;&lt;!-- ****************************************************** --&gt;Miscellaneous DevicesFM OPL3 The FM OPL3 is still used in many chips (mainly for backward compatibility)."
        },
         {
          "start_index": 547435,
           "end_index": 547760,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Buffer and Memory Management --&gt;&lt;!-- ****************************************************** --&gt;Buffer and Memory ManagementBuffer Types ALSA provides several different buffer allocation functions depending on the bus and the architecture."
        },
         {
          "start_index": 559377,
           "end_index": 559679,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Power Management --&gt;&lt;!-- ****************************************************** --&gt;Power Management If the chip is supposed to work with suspend/resume functions, you need to add power-management code to the driver."
        },
         {
          "start_index": 570159,
           "end_index": 570427,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends ALSA provides a verbose version of the printk() function."
        },
         {
          "start_index": 571943,
           "end_index": 572222,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document."
        }
      ]
    },
     {
      "group_id": 252,
       "duplicates": [
        {
          "start_index": 476812,
           "end_index": 476898,
           "text": "For accessing to the PCM layer, you need to include &amp;lt;sound/pcm.h&amp;gt; first."
        },
         {
          "start_index": 487564,
           "end_index": 487639,
           "text": "The definition of runtime instance is found in &amp;lt;sound/pcm.h&amp;gt;."
        },
         {
          "start_index": 504103,
           "end_index": 504206,
           "text": "Which action is specified in the second argument, SNDRV_PCM_TRIGGER_XXX in &amp;lt;sound/pcm.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        },
         {
          "start_index": 553885,
           "end_index": 553936,
           "text": "The API is provided in &amp;lt;sound/pcm.h&amp;gt;."
        },
         {
          "start_index": 556181,
           "end_index": 556230,
           "text": "The API is found in &amp;lt;sound/info.h&amp;gt;."
        }
      ]
    },
     {
      "group_id": 253,
       "duplicates": [
        {
          "start_index": 476899,
           "end_index": 477017,
           "text": "In addition, &amp;lt;sound/pcm_params.h&amp;gt; might be needed if you access to some functions related with hw_param."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 254,
       "duplicates": [
        {
          "start_index": 477808,
           "end_index": 477873,
           "text": "But you don&#39;t have to care about such details in your driver."
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 255,
       "duplicates": [
        {
          "start_index": 478077,
           "end_index": 483430,
           "text": "PCM Example Code #include &amp;lt;sound/pcm.h&amp;gt; .... /* hardware definition */ static struct snd_pcm_hardware snd_mychip_playback_hw = { .info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID), .formats = SNDRV_PCM_FMTBIT_S16_LE, .rates = SNDRV_PCM_RATE_8000_48000, .rate_min = 8000, .rate_max = 48000, .channels_min = 2, .channels_max = 2, .buffer_bytes_max = 32768, .period_bytes_min = 4096, .period_bytes_max = 32768, .periods_min = 1, .periods_max = 1024, }; /* hardware definition */ static struct snd_pcm_hardware snd_mychip_capture_hw = { .info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID), .formats = SNDRV_PCM_FMTBIT_S16_LE, .rates = SNDRV_PCM_RATE_8000_48000, .rate_min = 8000, .rate_max = 48000, .channels_min = 2, .channels_max = 2, .buffer_bytes_max = 32768, .period_bytes_min = 4096, .period_bytes_max = 32768, .periods_min = 1, .periods_max = 1024, }; /* open callback */ static int snd_mychip_playback_open(struct snd_pcm_substream *substream) { struct mychip *chip = snd_pcm_substream_chip(substream); struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime; runtime-&amp;gt;hw = snd_mychip_playback_hw; /* more hardware-initialization will be done here */ .... return 0; } /* close callback */ static int snd_mychip_playback_close(struct snd_pcm_substream *substream) { struct mychip *chip = snd_pcm_substream_chip(substream); /* the hardware-specific codes will be here */ .... return 0; } /* open callback */ static int snd_mychip_capture_open(struct snd_pcm_substream *substream) { struct mychip *chip = snd_pcm_substream_chip(substream); struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime; runtime-&amp;gt;hw = snd_mychip_capture_hw; /* more hardware-initialization will be done here */ .... return 0; } /* close callback */ static int snd_mychip_capture_close(struct snd_pcm_substream *substream) { struct mychip *chip = snd_pcm_substream_chip(substream); /* the hardware-specific codes will be here */ .... return 0; } /* hw_params callback */ static int snd_mychip_pcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *hw_params) { return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params)); } /* hw_free callback */ static int snd_mychip_pcm_hw_free(struct snd_pcm_substream *substream) { return snd_pcm_lib_free_pages(substream); } /* prepare callback */ static int snd_mychip_pcm_prepare(struct snd_pcm_substream *substream) { struct mychip *chip = snd_pcm_substream_chip(substream); struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime; /* set up the hardware with the current configuration * for example... */ mychip_set_sample_format(chip, runtime-&amp;gt;format); mychip_set_sample_rate(chip, runtime-&amp;gt;rate); mychip_set_channels(chip, runtime-&amp;gt;channels); mychip_set_dma_setup(chip, runtime-&amp;gt;dma_addr, chip-&amp;gt;buffer_size, chip-&amp;gt;period_size); return 0; } /* trigger callback */ static int snd_mychip_pcm_trigger(struct snd_pcm_substream *substream, int cmd) { switch (cmd) { case SNDRV_PCM_TRIGGER_START: /* do something to start the PCM engine */ .... break; case SNDRV_PCM_TRIGGER_STOP: /* do something to stop the PCM engine */ .... break; default: return -EINVAL; } } /* pointer callback */ static snd_pcm_uframes_t snd_mychip_pcm_pointer(struct snd_pcm_substream *substream) { struct mychip *chip = snd_pcm_substream_chip(substream); unsigned int current_ptr; /* get the current hardware pointer */ current_ptr = mychip_get_hw_pointer(chip); return current_ptr; } /* operators */ static struct snd_pcm_ops snd_mychip_playback_ops = { .open = snd_mychip_playback_open, .close = snd_mychip_playback_close, .ioctl = snd_pcm_lib_ioctl, .hw_params = snd_mychip_pcm_hw_params, .hw_free = snd_mychip_pcm_hw_free, .prepare = snd_mychip_pcm_prepare, .trigger = snd_mychip_pcm_trigger, .pointer = snd_mychip_pcm_pointer, }; /* operators */ static struct snd_pcm_ops snd_mychip_capture_ops = { .open = snd_mychip_capture_open, .close = snd_mychip_capture_close, .ioctl = snd_pcm_lib_ioctl, .hw_params = snd_mychip_pcm_hw_params, .hw_free = snd_mychip_pcm_hw_free, .prepare = snd_mychip_pcm_prepare, .trigger = snd_mychip_pcm_trigger, .pointer = snd_mychip_pcm_pointer, }; /* * definitions of capture are omitted here... */ /* create a pcm device */ static int snd_mychip_new_pcm(struct mychip *chip) { struct snd_pcm *pcm; int err; err = snd_pcm_new(chip-&amp;gt;card, &quot;My Chip&quot;, 0, 1, 1, &amp;amp;pcm); if (err &amp;lt; 0) return err; pcm-&amp;gt;private_data = chip; strcpy(pcm-&amp;gt;name, &quot;My Chip&quot;); chip-&amp;gt;pcm = pcm; /* set operators */ snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;amp;snd_mychip_playback_ops); snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;amp;snd_mychip_capture_ops); /* pre-allocation of buffers */ /* NOTE: this may fail */ snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip-&amp;gt;pci), 64*1024, 64*1024); return 0; } Constructor A pcm instance is allocated by the snd_pcm_new() function."
        },
         {
          "start_index": 483431,
           "end_index": 483863,
           "text": "It would be better to create a constructor for pcm, namely, static int snd_mychip_new_pcm(struct mychip *chip) { struct snd_pcm *pcm; int err; err = snd_pcm_new(chip-&amp;gt;card, &quot;My Chip&quot;, 0, 1, 1, &amp;amp;pcm); if (err &amp;lt; 0) return err; pcm-&amp;gt;private_data = chip; strcpy(pcm-&amp;gt;name, &quot;My Chip&quot;); chip-&amp;gt;pcm = pcm; .... return 0; } The snd_pcm_new() function takes four arguments."
        },
         {
          "start_index": 484889,
           "end_index": 485530,
           "text": "snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;amp;snd_mychip_playback_ops); snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;amp;snd_mychip_capture_ops); The operators are defined typically like this: static struct snd_pcm_ops snd_mychip_playback_ops = { .open = snd_mychip_pcm_open, .close = snd_mychip_pcm_close, .ioctl = snd_pcm_lib_ioctl, .hw_params = snd_mychip_pcm_hw_params, .hw_free = snd_mychip_pcm_hw_free, .prepare = snd_mychip_pcm_prepare, .trigger = snd_mychip_pcm_trigger, .pointer = snd_mychip_pcm_pointer, }; All the callbacks are described in the Operators subsection."
        },
         {
          "start_index": 485612,
           "end_index": 485834,
           "text": "For the pre-allocation, simply call the following: snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip-&amp;gt;pci), 64*1024, 64*1024); It will allocate a buffer up to 64kB as default."
        },
         {
          "start_index": 487329,
           "end_index": 487386,
           "text": "This pointer is accessible via substream-&amp;gt;runtime."
        },
         {
          "start_index": 487564,
           "end_index": 487639,
           "text": "The definition of runtime instance is found in &amp;lt;sound/pcm.h&amp;gt;."
        },
         {
          "start_index": 491286,
           "end_index": 492287,
           "text": "For example, if the maximum number of channels is 1 only on some chip models, you can still use the same hardware descriptor and change the channels_max later: struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime; ... runtime-&amp;gt;hw = snd_mychip_playback_hw; /* common definition */ if (chip-&amp;gt;model == VERY_OLD_ONE) runtime-&amp;gt;hw.channels_max = 1; Typically, you&#39;ll have a hardware descriptor as below: static struct snd_pcm_hardware snd_mychip_playback_hw = { .info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID), .formats = SNDRV_PCM_FMTBIT_S16_LE, .rates = SNDRV_PCM_RATE_8000_48000, .rate_min = 8000, .rate_max = 48000, .channels_min = 2, .channels_max = 2, .buffer_bytes_max = 32768, .period_bytes_min = 4096, .period_bytes_max = 32768, .periods_min = 1, .periods_max = 1024, }; The info field contains the type and capabilities of this pcm."
        },
         {
          "start_index": 498152,
           "end_index": 498201,
           "text": "Don&#39;t mix this with pcm-&amp;gt;private_data."
        },
         {
          "start_index": 499334,
           "end_index": 499505,
           "text": "int xxx() { struct mychip *chip = snd_pcm_substream_chip(substream); .... } The macro reads substream-&amp;gt;private_data, which is a copy of pcm-&amp;gt;private_data."
        },
         {
          "start_index": 499913,
           "end_index": 499981,
           "text": "At least, here you have to initialize the runtime-&amp;gt;hw record."
        },
         {
          "start_index": 499982,
           "end_index": 500333,
           "text": "Typically, this is done by like this: static int snd_xxx_open(struct snd_pcm_substream *substream) { struct mychip *chip = snd_pcm_substream_chip(substream); struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime; runtime-&amp;gt;hw = snd_mychip_playback_hw; return 0; } where snd_mychip_playback_hw is the pre-defined hardware description."
        },
         {
          "start_index": 503524,
           "end_index": 503679,
           "text": "For example, to get the current rate, format or channels, access to runtime-&amp;gt;rate, runtime-&amp;gt;format or runtime-&amp;gt;channels, respectively."
        },
         {
          "start_index": 503762,
           "end_index": 503871,
           "text": "The buffer and period sizes are in runtime-&amp;gt;buffer_size and runtime-&amp;gt;period_size, respectively."
        },
         {
          "start_index": 504103,
           "end_index": 504206,
           "text": "Which action is specified in the second argument, SNDRV_PCM_TRIGGER_XXX in &amp;lt;sound/pcm.h&amp;gt;."
        },
         {
          "start_index": 504281,
           "end_index": 504643,
           "text": "switch (cmd) { case SNDRV_PCM_TRIGGER_START: /* do something to start the PCM engine */ break; case SNDRV_PCM_TRIGGER_STOP: /* do something to stop the PCM engine */ break; default: return -EINVAL; } When the pcm supports the pause operation (given in the info field of the hardware table), the PAUSE_PUSH and PAUSE_RELEASE commands must be handled here, too."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        },
         {
          "start_index": 553885,
           "end_index": 553936,
           "text": "The API is provided in &amp;lt;sound/pcm.h&amp;gt;."
        },
         {
          "start_index": 556181,
           "end_index": 556230,
           "text": "The API is found in &amp;lt;sound/info.h&amp;gt;."
        }
      ]
    },
     {
      "group_id": 256,
       "duplicates": [
        {
          "start_index": 484579,
           "end_index": 484886,
           "text": "When you need to know which substream you are referring to, then it can be obtained from struct snd_pcm_substream data passed to each callback as follows: struct snd_pcm_substream *substream; int index = substream-&amp;gt;number; After the pcm is created, you need to set operators for each pcm stream."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 257,
       "duplicates": [
        {
          "start_index": 485835,
           "end_index": 485929,
           "text": "Buffer management details will be described in the later section Buffer and Memory Management."
        },
         {
          "start_index": 506593,
           "end_index": 506674,
           "text": "The detailed will be described in the later section Buffer and Memory Management."
        }
      ]
    },
     {
      "group_id": 258,
       "duplicates": [
        {
          "start_index": 485931,
           "end_index": 486019,
           "text": "Additionally, you can set some extra information for this pcm in pcm-&amp;gt;info_flags."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 259,
       "duplicates": [
        {
          "start_index": 486020,
           "end_index": 486170,
           "text": "The available values are defined as SNDRV_PCM_INFO_XXX in &amp;lt;sound/asound.h&amp;gt;, which is used for the hardware definition (described later)."
        },
         {
          "start_index": 492288,
           "end_index": 492370,
           "text": "The bit flags are defined in &amp;lt;sound/asound.h&amp;gt; as SNDRV_PCM_INFO_XXX."
        },
         {
          "start_index": 515430,
           "end_index": 515492,
           "text": "The control API is defined in &amp;lt;sound/control.h&amp;gt;."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        },
         {
          "start_index": 526845,
           "end_index": 526913,
           "text": "The AC97 codec API is defined in &amp;lt;sound/ac97_codec.h&amp;gt;."
        },
         {
          "start_index": 532638,
           "end_index": 532703,
           "text": "The MPU401-UART API is defined in &amp;lt;sound/mpu401.h&amp;gt;."
        },
         {
          "start_index": 536469,
           "end_index": 536531,
           "text": "The rawmidi API is defined in &amp;lt;sound/rawmidi.h&amp;gt;."
        },
         {
          "start_index": 542554,
           "end_index": 542610,
           "text": "The OPL3 API is defined in &amp;lt;sound/opl3.h&amp;gt;."
        },
         {
          "start_index": 544914,
           "end_index": 544972,
           "text": "The hwdep API is defined in &amp;lt;sound/hwdep.h&amp;gt;."
        }
      ]
    },
     {
      "group_id": 260,
       "duplicates": [
        {
          "start_index": 486171,
           "end_index": 486317,
           "text": "When your soundchip supports only half-duplex, specify like this: pcm-&amp;gt;info_flags = SNDRV_PCM_INFO_HALF_DUPLEX; ... And the Destructor?"
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 261,
       "duplicates": [
        {
          "start_index": 486614,
           "end_index": 487328,
           "text": "In such a case, set the destructor function to pcm-&amp;gt;private_free: PCM Instance with a Destructor static void mychip_pcm_free(struct snd_pcm *pcm) { struct mychip *chip = snd_pcm_chip(pcm); /* free your own data */ kfree(chip-&amp;gt;my_private_pcm_data); /* do what you like else */ .... } static int snd_mychip_new_pcm(struct mychip *chip) { struct snd_pcm *pcm; .... /* allocate your own data */ chip-&amp;gt;my_private_pcm_data = kmalloc(...); /* set the destructor */ pcm-&amp;gt;private_data = chip; pcm-&amp;gt;private_free = mychip_pcm_free; .... } Runtime Pointer - The Chest of PCM Information When the PCM substream is opened, a PCM runtime instance is allocated and assigned to the substream."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 262,
       "duplicates": [
        {
          "start_index": 491183,
           "end_index": 491284,
           "text": "That is, in the open callback, you can modify the copied descriptor (runtime-&amp;gt;hw) as you need."
        },
         {
          "start_index": 499913,
           "end_index": 499981,
           "text": "At least, here you have to initialize the runtime-&amp;gt;hw record."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 263,
       "duplicates": [
        {
          "start_index": 493365,
           "end_index": 493406,
           "text": "See Power Management section for details."
        },
         {
          "start_index": 505121,
           "end_index": 505166,
           "text": "See the Power Management section for details."
        }
      ]
    },
     {
      "group_id": 264,
       "duplicates": [
        {
          "start_index": 493572,
           "end_index": 493669,
           "text": "In this case, you&#39;ll need to check the linked-list of PCM substreams in the trigger callback."
        },
         {
          "start_index": 519429,
           "end_index": 519489,
           "text": "In this case, you don&#39;t have to define the put callback."
        }
      ]
    },
     {
      "group_id": 265,
       "duplicates": [
        {
          "start_index": 495499,
           "end_index": 495573,
           "text": "PCM Configurations Ok, let&#39;s go back again to the PCM runtime records."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 266,
       "duplicates": [
        {
          "start_index": 496251,
           "end_index": 496393,
           "text": "period_bytes = frames_to_bytes(runtime, runtime-&amp;gt;period_size); Also, many software parameters (sw_params) are stored in frames, too."
        },
         {
          "start_index": 503762,
           "end_index": 503871,
           "text": "The buffer and period sizes are in runtime-&amp;gt;buffer_size and runtime-&amp;gt;period_size, respectively."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 267,
       "duplicates": [
        {
          "start_index": 497569,
           "end_index": 497646,
           "text": "Running Status The running status can be referred via runtime-&amp;gt;status."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 268,
       "duplicates": [
        {
          "start_index": 497710,
           "end_index": 497810,
           "text": "For example, you can get the current DMA hardware pointer via runtime-&amp;gt;status-&amp;gt;hw_ptr."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 269,
       "duplicates": [
        {
          "start_index": 497812,
           "end_index": 497940,
           "text": "The DMA application pointer can be referred via runtime-&amp;gt;control, which points to the struct snd_pcm_mmap_control record."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 270,
       "duplicates": [
        {
          "start_index": 498003,
           "end_index": 498105,
           "text": "Private Data You can allocate a record for the substream and store it in runtime-&amp;gt;private_data."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 271,
       "duplicates": [
        {
          "start_index": 498202,
           "end_index": 498418,
           "text": "The pcm-&amp;gt;private_data usually points to the chip instance assigned statically at the creation of PCM, while the runtime-&amp;gt;private_data points to a dynamic data structure created at the PCM open callback."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 272,
       "duplicates": [
        {
          "start_index": 498421,
           "end_index": 498684,
           "text": "static int snd_xxx_open(struct snd_pcm_substream *substream) { struct my_pcm_data *data; .... data = kmalloc(sizeof(*data), GFP_KERNEL); substream-&amp;gt;runtime-&amp;gt;private_data = data; .... } The allocated object must be released in the close callback."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 273,
       "duplicates": [
        {
          "start_index": 498910,
           "end_index": 499009,
           "text": "In general, every callback must return 0 if successful, or a negative error number such as -EINVAL."
        },
         {
          "start_index": 578887,
           "end_index": 578907,
           "text": "If so, it returns 0."
        }
      ]
    },
     {
      "group_id": 274,
       "duplicates": [
        {
          "start_index": 500552,
           "end_index": 500690,
           "text": "close callback static int snd_xxx_close(struct snd_pcm_substream *substream); Obviously, this is called when a pcm substream is closed."
        },
         {
          "start_index": 539259,
           "end_index": 539354,
           "text": "close callback static int snd_xxx_close(struct snd_rawmidi_substream *substream); Guess what."
        }
      ]
    },
     {
      "group_id": 275,
       "duplicates": [
        {
          "start_index": 500789,
           "end_index": 500985,
           "text": "static int snd_xxx_close(struct snd_pcm_substream *substream) { .... kfree(substream-&amp;gt;runtime-&amp;gt;private_data); .... } ioctl callback This is used for any special call to pcm ioctls."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 276,
       "duplicates": [
        {
          "start_index": 501796,
           "end_index": 501881,
           "text": "Note that this and prepare callbacks may be called multiple times per initialization."
        },
         {
          "start_index": 502848,
           "end_index": 502901,
           "text": "Also, the callback may be called multiple times, too."
        }
      ]
    },
     {
      "group_id": 277,
       "duplicates": [
        {
          "start_index": 502211,
           "end_index": 502274,
           "text": "Another note is that this callback is non-atomic (schedulable)."
        },
         {
          "start_index": 503300,
           "end_index": 503342,
           "text": "Note that this callback is now non-atomic."
        }
      ]
    },
     {
      "group_id": 278,
       "duplicates": [
        {
          "start_index": 503408,
           "end_index": 503523,
           "text": "In this and the following callbacks, you can refer to the values via the runtime record, substream-&amp;gt;runtime."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 279,
       "duplicates": [
        {
          "start_index": 503680,
           "end_index": 503760,
           "text": "The physical address of the allocated buffer is set to runtime-&amp;gt;dma_area."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        },
         {
          "start_index": 554672,
           "end_index": 554733,
           "text": "The virtual pointer is addressed in runtime-&amp;gt;dma_area."
        }
      ]
    },
     {
      "group_id": 280,
       "duplicates": [
        {
          "start_index": 506986,
           "end_index": 507030,
           "text": "page callback This callback is optional too."
        },
         {
          "start_index": 542077,
           "end_index": 542103,
           "text": "This callback is optional."
        }
      ]
    },
     {
      "group_id": 281,
       "duplicates": [
        {
          "start_index": 508403,
           "end_index": 510065,
           "text": "Typical code would be like: Interrupt Handler Case #1 static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id) { struct mychip *chip = dev_id; spin_lock(&amp;amp;chip-&amp;gt;lock); .... if (pcm_irq_invoked(chip)) { /* call updater, unlock before it */ spin_unlock(&amp;amp;chip-&amp;gt;lock); snd_pcm_period_elapsed(chip-&amp;gt;substream); spin_lock(&amp;amp;chip-&amp;gt;lock); /* acknowledge the interrupt if necessary */ } .... spin_unlock(&amp;amp;chip-&amp;gt;lock); return IRQ_HANDLED; } High frequency timer interrupts This happens when the hardware doesn&#39;t generate interrupts at the period boundary but issues timer interrupts at a fixed timer rate (e.g. es1968 or ymfpci drivers). In this case, you need to check the current hardware position and accumulate the processed sample length at each interrupt. When the accumulated size exceeds the period size, call snd_pcm_period_elapsed() and reset the accumulator. Typical code would be like the following. Interrupt Handler Case #2 static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id) { struct mychip *chip = dev_id; spin_lock(&amp;amp;chip-&amp;gt;lock); .... if (pcm_irq_invoked(chip)) { unsigned int last_ptr, size; /* get the current hardware pointer (in frames) */ last_ptr = get_hw_ptr(chip); /* calculate the processed frames since the * last update */ if (last_ptr &amp;lt; chip-&amp;gt;last_ptr) size = runtime-&amp;gt;buffer_size + last_ptr - chip-&amp;gt;last_ptr; else size = last_ptr - chip-&amp;gt;last_ptr; /* remember the last updated point */ chip-&amp;gt;last_ptr = last_ptr; /* accumulate the size */ chip-&amp;gt;size += size; /* over the period boundary?"
        },
         {
          "start_index": 510066,
           "end_index": 511095,
           "text": "*/ if (chip-&amp;gt;size &amp;gt;= runtime-&amp;gt;period_size) { /* reset the accumulator */ chip-&amp;gt;size %= runtime-&amp;gt;period_size; /* call updater */ spin_unlock(&amp;amp;chip-&amp;gt;lock); snd_pcm_period_elapsed(substream); spin_lock(&amp;amp;chip-&amp;gt;lock); } /* acknowledge the interrupt if necessary */ } .... spin_unlock(&amp;amp;chip-&amp;gt;lock); return IRQ_HANDLED; } On calling snd_pcm_period_elapsed() In both cases, even if more than one period are elapsed, you don&#39;t have to call snd_pcm_period_elapsed() many times. Call only once. And the pcm layer will check the current hardware pointer and update to the latest status. Atomicity One of the most important (and thus difficult to debug) problems in kernel programming are race conditions. In the Linux kernel, they are usually avoided via spin-locks, mutexes or semaphores. In general, if a race condition can happen in an interrupt handler, it has to be managed atomically, and you have to use a spinlock to protect the critical session."
        }
      ]
    },
     {
      "group_id": 282,
       "duplicates": [
        {
          "start_index": 512286,
           "end_index": 512778,
           "text": "Example of Hardware Constraints static unsigned int rates[] = {4000, 10000, 22050, 44100}; static struct snd_pcm_hw_constraint_list constraints_rates = { .count = ARRAY_SIZE(rates), .list = rates, .mask = 0, }; static int snd_mychip_pcm_open(struct snd_pcm_substream *substream) { int err; .... err = snd_pcm_hw_constraint_list(substream-&amp;gt;runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &amp;amp;constraints_rates); if (err &amp;lt; 0) return err; .... } There are many different constraints."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 283,
       "duplicates": [
        {
          "start_index": 512867,
           "end_index": 513090,
           "text": "For example, let&#39;s suppose my_chip can manage a substream of 1 channel if and only if the format is S16_LE, otherwise it supports any format specified in the snd_pcm_hardware structure (or in any other constraint_list)."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 284,
       "duplicates": [
        {
          "start_index": 513091,
           "end_index": 513954,
           "text": "You can build a rule like this: Example of Hardware Constraints for Channels static int hw_rule_channels_by_format(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule) { struct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS); struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT); struct snd_interval ch; snd_interval_any(&amp;amp;ch); if (f-&amp;gt;bits[0] == SNDRV_PCM_FMTBIT_S16_LE) { ch.min = ch.max = 1; ch.integer = 1; return snd_interval_refine(c, &amp;amp;ch); } return 0; } Then you need to call this function to add your rule: snd_pcm_hw_rule_add(substream-&amp;gt;runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, hw_rule_channels_by_format, NULL, SNDRV_PCM_HW_PARAM_FORMAT, -1); The rule function is called when an application sets the PCM format, and it refines the number of channels accordingly."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 285,
       "duplicates": [
        {
          "start_index": 514032,
           "end_index": 514856,
           "text": "Thus you also need to define the inverse rule: Example of Hardware Constraints for Formats static int hw_rule_format_by_channels(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule) { struct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS); struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT); struct snd_mask fmt; snd_mask_any(&amp;amp;fmt); /* Init the struct */ if (c-&amp;gt;min &amp;lt; 2) { fmt.bits[0] &amp;amp;= SNDRV_PCM_FMTBIT_S16_LE; return snd_mask_refine(f, &amp;amp;fmt); } return 0; } ...and in the open callback: snd_pcm_hw_rule_add(substream-&amp;gt;runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT, hw_rule_format_by_channels, NULL, SNDRV_PCM_HW_PARAM_CHANNELS, -1); I won&#39;t give more details here, rather I would like to say, Luke, use the source."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 286,
       "duplicates": [
        {
          "start_index": 519490,
           "end_index": 519641,
           "text": "Similarly, when the control is write-only (although it&#39;s a rare case), you can use the WRITE flag instead, and you don&#39;t need the get callback."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 287,
       "duplicates": [
        {
          "start_index": 520144,
           "end_index": 520538,
           "text": "For example, for a boolean control with a single element: Example of info callback static int snd_myctl_mono_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo) { uinfo-&amp;gt;type = SNDRV_CTL_ELEM_TYPE_BOOLEAN; uinfo-&amp;gt;count = 1; uinfo-&amp;gt;value.integer.min = 0; uinfo-&amp;gt;value.integer.max = 1; return 0; } The type field specifies the type of the control."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 288,
       "duplicates": [
        {
          "start_index": 520901,
           "end_index": 520970,
           "text": "You&#39;ll need to set the string for the currently given item index."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        },
         {
          "start_index": 569228,
           "end_index": 569285,
           "text": "You don&#39;t need to give the lowlevel selections again."
        }
      ]
    },
     {
      "group_id": 289,
       "duplicates": [
        {
          "start_index": 520973,
           "end_index": 521618,
           "text": "static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo) { static char *texts[4] = { &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot; }; uinfo-&amp;gt;type = SNDRV_CTL_ELEM_TYPE_ENUMERATED; uinfo-&amp;gt;count = 1; uinfo-&amp;gt;value.enumerated.items = 4; if (uinfo-&amp;gt;value.enumerated.item &amp;gt; 3) uinfo-&amp;gt;value.enumerated.item = 3; strcpy(uinfo-&amp;gt;value.enumerated.name, texts[uinfo-&amp;gt;value.enumerated.item]); return 0; } Some common info callbacks are available for your convenience: snd_ctl_boolean_mono_info() and snd_ctl_boolean_stereo_info()."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 290,
       "duplicates": [
        {
          "start_index": 521890,
           "end_index": 522232,
           "text": "For example, Example of get callback static int snd_myctl_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol) { struct mychip *chip = snd_kcontrol_chip(kcontrol); ucontrol-&amp;gt;value.integer.value[0] = get_some_value(chip); return 0; } The value field depends on the type of control as well as on the info callback."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 291,
       "duplicates": [
        {
          "start_index": 522340,
           "end_index": 522936,
           "text": "The private_value field is set as follows: .private_value = reg | (shift &amp;lt;&amp;lt; 16) | (mask &amp;lt;&amp;lt; 24) and is retrieved in callbacks like static int snd_sbmixer_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol) { int reg = kcontrol-&amp;gt;private_value &amp;amp; 0xff; int shift = (kcontrol-&amp;gt;private_value &amp;gt;&amp;gt; 16) &amp;amp; 0xff; int mask = (kcontrol-&amp;gt;private_value &amp;gt;&amp;gt; 24) &amp;amp; 0xff; .... } In the get callback, you have to fill all the elements if the control has more than one elements, i.e."
        },
         {
          "start_index": 522937,
           "end_index": 522954,
           "text": "count &amp;gt; 1."
        }
      ]
    },
     {
      "group_id": 292,
       "duplicates": [
        {
          "start_index": 525819,
           "end_index": 526083,
           "text": "The first parameter is the name of the variable to be defined. The second parameter is the minimum value, in units of 0.01 dB. The third parameter is the step size, in units of 0.01 dB. Set the fourth parameter to 1 if the minimum value actually mutes the control."
        },
         {
          "start_index": 526218,
           "end_index": 526493,
           "text": "The first parameter is the name of the variable to be defined. The second parameter is the minimum value, in units of 0.01 dB. The third parameter is the maximum value, in units of 0.01 dB. If the minimum value mutes the control, set the second parameter to TLV_DB_GAIN_MUTE."
        }
      ]
    },
     {
      "group_id": 293,
       "duplicates": [
        {
          "start_index": 526494,
           "end_index": 526797,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- API for AC97 Codec --&gt;&lt;!-- ****************************************************** --&gt;API for AC97 CodecGeneral The ALSA AC97 codec layer is a well-defined one, and you don&#39;t have to write much code to control it."
        },
         {
          "start_index": 532245,
           "end_index": 532523,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- MIDI (MPU401-UART) Interface --&gt;&lt;!-- ****************************************************** --&gt;MIDI (MPU401-UART) InterfaceGeneral Many soundcards have built-in MIDI (MPU401-UART) interfaces."
        },
         {
          "start_index": 542229,
           "end_index": 542509,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Miscellaneous Devices --&gt;&lt;!-- ****************************************************** --&gt;Miscellaneous DevicesFM OPL3 The FM OPL3 is still used in many chips (mainly for backward compatibility)."
        },
         {
          "start_index": 547435,
           "end_index": 547760,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Buffer and Memory Management --&gt;&lt;!-- ****************************************************** --&gt;Buffer and Memory ManagementBuffer Types ALSA provides several different buffer allocation functions depending on the bus and the architecture."
        },
         {
          "start_index": 559377,
           "end_index": 559679,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Power Management --&gt;&lt;!-- ****************************************************** --&gt;Power Management If the chip is supposed to work with suspend/resume functions, you need to add power-management code to the driver."
        },
         {
          "start_index": 570159,
           "end_index": 570427,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends ALSA provides a verbose version of the printk() function."
        },
         {
          "start_index": 571943,
           "end_index": 572222,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document."
        }
      ]
    },
     {
      "group_id": 294,
       "duplicates": [
        {
          "start_index": 526914,
           "end_index": 528024,
           "text": "Full Code ExampleExample of AC97 Interface struct mychip { .... struct snd_ac97 *ac97; .... }; static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97, unsigned short reg) { struct mychip *chip = ac97-&amp;gt;private_data; .... /* read a register value here from the codec */ return the_register_value; } static void snd_mychip_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val) { struct mychip *chip = ac97-&amp;gt;private_data; .... /* write the given register value to the codec */ } static int snd_mychip_ac97(struct mychip *chip) { struct snd_ac97_bus *bus; struct snd_ac97_template ac97; int err; static struct snd_ac97_bus_ops ops = { .write = snd_mychip_ac97_write, .read = snd_mychip_ac97_read, }; err = snd_ac97_bus(chip-&amp;gt;card, 0, &amp;amp;ops, NULL, &amp;amp;bus); if (err &amp;lt; 0) return err; memset(&amp;amp;ac97, 0, sizeof(ac97)); ac97.private_data = chip; return snd_ac97_mixer(bus, &amp;amp;ac97, &amp;amp;chip-&amp;gt;ac97); } Constructor To create an ac97 instance, first call snd_ac97_bus with an ac97_bus_ops_t record with callback functions."
        },
         {
          "start_index": 528027,
           "end_index": 528279,
           "text": "struct snd_ac97_bus *bus; static struct snd_ac97_bus_ops ops = { .write = snd_mychip_ac97_write, .read = snd_mychip_ac97_read, }; snd_ac97_bus(card, 0, &amp;amp;ops, NULL, &amp;amp;pbus); The bus record is shared among all belonging ac97 instances."
        },
         {
          "start_index": 528399,
           "end_index": 528645,
           "text": "struct snd_ac97_template ac97; int err; memset(&amp;amp;ac97, 0, sizeof(ac97)); ac97.private_data = chip; snd_ac97_mixer(bus, &amp;amp;ac97, &amp;amp;chip-&amp;gt;ac97); where chip-&amp;gt;ac97 is a pointer to a newly created ac97_t instance."
        },
         {
          "start_index": 529233,
           "end_index": 529465,
           "text": "static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97, unsigned short reg) { struct mychip *chip = ac97-&amp;gt;private_data; .... return the_register_value; } Here, the chip can be cast from ac97-&amp;gt;private_data."
        },
         {
          "start_index": 529534,
           "end_index": 529696,
           "text": "static void snd_mychip_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val) These callbacks are non-atomic like the control API callbacks."
        }
      ]
    },
     {
      "group_id": 295,
       "duplicates": [
        {
          "start_index": 533115,
           "end_index": 533154,
           "text": "You can create up to 8 rawmidi devices."
        },
         {
          "start_index": 537086,
           "end_index": 537125,
           "text": "You can create up to 8 rawmidi devices."
        }
      ]
    },
     {
      "group_id": 296,
       "duplicates": [
        {
          "start_index": 535899,
           "end_index": 536257,
           "text": "snd_mpu401_uart_interrupt(irq, rmidi-&amp;gt;private_data, regs); &lt;!-- ****************************************************** --&gt;&lt;!-- RawMIDI Interface --&gt;&lt;!-- ****************************************************** --&gt;RawMIDI InterfaceOverview The raw MIDI interface is used for hardware MIDI ports that can be accessed as a byte stream."
        },
         {
          "start_index": 542229,
           "end_index": 542509,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Miscellaneous Devices --&gt;&lt;!-- ****************************************************** --&gt;Miscellaneous DevicesFM OPL3 The FM OPL3 is still used in many chips (mainly for backward compatibility)."
        },
         {
          "start_index": 547435,
           "end_index": 547760,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Buffer and Memory Management --&gt;&lt;!-- ****************************************************** --&gt;Buffer and Memory ManagementBuffer Types ALSA provides several different buffer allocation functions depending on the bus and the architecture."
        },
         {
          "start_index": 559377,
           "end_index": 559679,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Power Management --&gt;&lt;!-- ****************************************************** --&gt;Power Management If the chip is supposed to work with suspend/resume functions, you need to add power-management code to the driver."
        },
         {
          "start_index": 570159,
           "end_index": 570427,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends ALSA provides a verbose version of the printk() function."
        },
         {
          "start_index": 571943,
           "end_index": 572222,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document."
        }
      ]
    },
     {
      "group_id": 297,
       "duplicates": [
        {
          "start_index": 538209,
           "end_index": 538740,
           "text": "If there are more than one substream, you should give a unique name to each of them: struct snd_rawmidi_substream *substream; list_for_each_entry(substream, &amp;amp;rmidi-&amp;gt;streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams, list { sprintf(substream-&amp;gt;name, &quot;My MIDI Port %d&quot;, substream-&amp;gt;number + 1); } /* same for SNDRV_RAWMIDI_STREAM_INPUT */ Callbacks In all the callbacks, the private data that you&#39;ve set for the rawmidi device can be accessed as substream-&amp;gt;rmidi-&amp;gt;private_data."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 298,
       "duplicates": [
        {
          "start_index": 539449,
           "end_index": 539691,
           "text": "trigger callback for output substreams static void snd_xxx_output_trigger(struct snd_rawmidi_substream *substream, int up); This is called with a nonzero up parameter when there is some data in the substream buffer that must be transmitted."
        },
         {
          "start_index": 541108,
           "end_index": 541355,
           "text": "trigger callback for input substreams static void snd_xxx_input_trigger(struct snd_rawmidi_substream *substream, int up); This is called with a nonzero up parameter to enable receiving data, or with a zero up parameter do disable receiving data."
        }
      ]
    },
     {
      "group_id": 299,
       "duplicates": [
        {
          "start_index": 555195,
           "end_index": 555315,
           "text": "Vmalloc&#39;ed Buffers It&#39;s possible to use a buffer allocated via vmalloc, for example, for an intermediate buffer."
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 300,
       "duplicates": [
        {
          "start_index": 555445,
           "end_index": 556026,
           "text": "The implementation of page callback would be like this: #include &amp;lt;linux/vmalloc.h&amp;gt; /* get the physical page pointer on the given offset */ static struct page *mychip_page(struct snd_pcm_substream *substream, unsigned long offset) { void *pageptr = substream-&amp;gt;runtime-&amp;gt;dma_area + offset; return vmalloc_to_page(pageptr); } &lt;!-- ****************************************************** --&gt;&lt;!-- Proc Interface --&gt;&lt;!-- ****************************************************** --&gt;Proc Interface ALSA provides an easy interface for procfs."
        },
         {
          "start_index": 559377,
           "end_index": 559679,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Power Management --&gt;&lt;!-- ****************************************************** --&gt;Power Management If the chip is supposed to work with suspend/resume functions, you need to add power-management code to the driver."
        },
         {
          "start_index": 570159,
           "end_index": 570427,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends ALSA provides a verbose version of the printk() function."
        },
         {
          "start_index": 571943,
           "end_index": 572222,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document."
        }
      ]
    },
     {
      "group_id": 301,
       "duplicates": [
        {
          "start_index": 557818,
           "end_index": 557870,
           "text": "As default, it&#39;s set as read only for all users."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 302,
       "duplicates": [
        {
          "start_index": 559281,
           "end_index": 559375,
           "text": "You don&#39;t have to check the range in the callbacks unless any other condition is required."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 303,
       "duplicates": [
        {
          "start_index": 560442,
           "end_index": 560556,
           "text": "Hence, you can define suspend/resume callbacks below but don&#39;t set SNDRV_PCM_INFO_RESUME info flag to the PCM."
        },
         {
          "start_index": 563860,
           "end_index": 563882,
           "text": "Let&#39;s set them up."
        }
      ]
    },
     {
      "group_id": 304,
       "duplicates": [
        {
          "start_index": 560901,
           "end_index": 560960,
           "text": "But, it&#39;s better to keep it for compatibility reasons.)"
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 305,
       "duplicates": [
        {
          "start_index": 561931,
           "end_index": 562774,
           "text": "A typical code would be like: static int mychip_suspend(struct pci_dev *pci, pm_message_t state) { /* (1) */ struct snd_card *card = pci_get_drvdata(pci); struct mychip *chip = card-&amp;gt;private_data; /* (2) */ snd_power_change_state(card, SNDRV_CTL_POWER_D3hot); /* (3) */ snd_pcm_suspend_all(chip-&amp;gt;pcm); /* (4) */ snd_ac97_suspend(chip-&amp;gt;ac97); /* (5) */ snd_mychip_save_registers(chip); /* (6) */ snd_mychip_stop_hardware(chip); /* (7) */ pci_disable_device(pci); pci_save_state(pci); return 0; } The scheme of the real resume job is as follows. Retrieve the card and the chip data.Set up PCI. First, call pci_restore_state(). Then enable the pci device again by calling pci_enable_device(). Call pci_set_master() if necessary, too.Re-initialize the chip.Restore the saved registers if necessary.Resume the mixer, e.g."
        },
         {
          "start_index": 562911,
           "end_index": 563859,
           "text": "A typical code would be like: static int mychip_resume(struct pci_dev *pci) { /* (1) */ struct snd_card *card = pci_get_drvdata(pci); struct mychip *chip = card-&amp;gt;private_data; /* (2) */ pci_restore_state(pci); pci_enable_device(pci); pci_set_master(pci); /* (3) */ snd_mychip_reinit_chip(chip); /* (4) */ snd_mychip_restore_registers(chip); /* (5) */ snd_ac97_resume(chip-&amp;gt;ac97); /* (6) */ snd_mychip_restart_chip(chip); /* (7) */ snd_power_change_state(card, SNDRV_CTL_POWER_D0); return 0; } As shown in the above, it&#39;s better to save registers after suspending the PCM operations via snd_pcm_suspend_all() or snd_pcm_suspend(). It means that the PCM streams are already stoppped when the register snapshot is taken. But, remember that you don&#39;t have to restart the PCM stream in the resume callback. It&#39;ll be restarted via trigger call with SNDRV_PCM_TRIGGER_RESUME when necessary. OK, we have all callbacks now."
        }
      ]
    },
     {
      "group_id": 306,
       "duplicates": [
        {
          "start_index": 564067,
           "end_index": 564494,
           "text": "static int snd_mychip_probe(struct pci_dev *pci, const struct pci_device_id *pci_id) { .... struct snd_card *card; struct mychip *chip; int err; .... err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;amp;card); .... chip = kzalloc(sizeof(*chip), GFP_KERNEL); .... card-&amp;gt;private_data = chip; .... } When you created the chip data with snd_card_create(), it&#39;s anyway accessible via private_data field."
        },
         {
          "start_index": 564497,
           "end_index": 564950,
           "text": "static int snd_mychip_probe(struct pci_dev *pci, const struct pci_device_id *pci_id) { .... struct snd_card *card; struct mychip *chip; int err; .... err = snd_card_create(index[dev], id[dev], THIS_MODULE, sizeof(struct mychip), &amp;amp;card); .... chip = card-&amp;gt;private_data; .... } If you need a space to save the registers, allocate the buffer for it here, too, since it would be fatal if you cannot allocate a memory in the suspend phase."
        }
      ]
    },
     {
      "group_id": 307,
       "duplicates": [
        {
          "start_index": 565085,
           "end_index": 565530,
           "text": "static struct pci_driver driver = { .name = KBUILD_MODNAME, .id_table = snd_my_ids, .probe = snd_my_probe, .remove = snd_my_remove, #ifdef CONFIG_PM .suspend = snd_my_suspend, .resume = snd_my_resume, #endif }; &lt;!-- ****************************************************** --&gt;&lt;!-- Module Parameters --&gt;&lt;!-- ****************************************************** --&gt;Module Parameters There are standard module options for ALSA."
        },
         {
          "start_index": 570159,
           "end_index": 570427,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends ALSA provides a verbose version of the printk() function."
        },
         {
          "start_index": 571943,
           "end_index": 572222,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document."
        }
      ]
    },
     {
      "group_id": 308,
       "duplicates": [
        {
          "start_index": 566968,
           "end_index": 567384,
           "text": "MODULE_DESCRIPTION(&quot;My Chip&quot;); MODULE_LICENSE(&quot;GPL&quot;); MODULE_SUPPORTED_DEVICE(&quot;{{Vendor,My Chip Name}}&quot;); &lt;!-- ****************************************************** --&gt;&lt;!-- How To Put Your Driver --&gt;&lt;!-- ****************************************************** --&gt;How To Put Your Driver Into ALSA TreeGeneral So far, you&#39;ve learned how to write the driver codes."
        },
         {
          "start_index": 570159,
           "end_index": 570427,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends ALSA provides a verbose version of the printk() function."
        },
         {
          "start_index": 571943,
           "end_index": 572222,
           "text": "&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments I would like to thank Phil Kerr for his help for improvement and corrections of this document."
        }
      ]
    },
     {
      "group_id": 309,
       "duplicates": [
        {
          "start_index": 569358,
           "end_index": 569448,
           "text": "Run cvscompile script to re-generate the configure script and build the whole stuff again."
        },
         {
          "start_index": 570067,
           "end_index": 570157,
           "text": "Run cvscompile script to re-generate the configure script and build the whole stuff again."
        }
      ]
    },
     {
      "group_id": 310,
       "duplicates": [
        {
          "start_index": 571394,
           "end_index": 571451,
           "text": "It&#39;s useful to show that a fatal error happens there."
        },
         {
          "start_index": 590639,
           "end_index": 590670,
           "text": "This isn&#39;t always the case."
        }
      ]
    },
     {
      "group_id": 311,
       "duplicates": [
        {
          "start_index": 591260,
           "end_index": 591330,
           "text": "If the checks fail to pass the function returns a non zero error code."
        },
         {
          "start_index": 596337,
           "end_index": 596383,
           "text": "This returns a non zero error code on failure."
        }
      ]
    },
     {
      "group_id": 312,
       "duplicates": [
        {
          "start_index": 595380,
           "end_index": 595429,
           "text": "On a failure a non zero error status is returned."
        },
         {
          "start_index": 595893,
           "end_index": 595939,
           "text": "On failure a non zero error value is returned."
        }
      ]
    }
  ]
}